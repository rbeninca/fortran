// --- Vari√°veis Globais da UI ---
let chart;
let dataWorker;
let MAX_DATA_POINTS = 100; // Changed from const to let
let chartMode = 'deslizante';
let wasAccumulating = false; // Track if we were in accumulated mode before pausing
let displayUnit = 'kgf';
let maxForceInN = -Infinity;
let minForceInN = Infinity;
let rawDataN = []; // Mantido para convers√£o de unidades
let isSessionActive = false;
let isChartPaused = false;
let chartUpdateBuffer = [];
let animationFrameId = null;
let originalChartContainer = null; // New global variable to store original parent
let originalChartSessionControlsContainer = null; // New global variable for session controls
let originalChartControlsParent = null; // Parent of the specific chart controls
let taxaAtualizacaoMs = 100; // Taxa de atualiza√ß√£o em ms (padr√£o 100ms = 10 Hz)
let dataRequestIntervalId = null; // ID do intervalo de solicita√ß√£o de dados
let btnToggleLabels, btnToggleDisplayMode, btnToggleGrid, btnSetSmoothLine, btnSetStraightLine;
let isMysqlConnected = false; // NEW: Global variable for MySQL connection status
let serverTimeOffset = 0; // Diferen√ßa entre servidor e cliente (ms)

// --- Vari√°veis de Filtros e An√°lise ---
let antiNoisingAtivo = false;
let isStabilityMode = false;
let noiseBuffer = [];
const NOISE_BUFFER_SIZE = 50;
let currentStdDev = 0;
let noiseMean = 0;
let antiNoisingMultiplier = 2.0;

// --- Vari√°veis para Especifica√ß√µes da C√©lula ---
let capacidadeMaximaGramas = 5000.0;
let percentualAcuracia = 0.05;
let filtroZonaMortaAtivo = true;
let arredondamentoInteligenteAtivo = true;

// --- Vari√°veis de √Åudio e Alertas ---
let avisosAudioAtivados = false;
let audioContext = null;
let ultimoStatusEstabilizacao = true;
let contadorFalhasEstabilizacao = 0;

// --- Fun√ß√µes de Inicializa√ß√£o ---
window.onload = () => {
  // Carregar configura√ß√µes salvas ANTES de tudo
  carregarConfiguracoesGrafico();
  
  // Conectar ao worker IMEDIATAMENTE (antes de aguardar o onload completo)
  conectarWorkerRapido();
  
  abrirAba(document.getElementById("padrao"), 'abaGrafico');
  initializeApexChart(); // NOVA FUN√á√ÉO DE GR√ÅFICO
  setDisplayUnit('kgf');
  setChartMode('deslizante');
  
  // Inicia o intervalo din√¢mico de solicita√ß√£o de dados
  iniciarIntervaloAtualizacao();
  
  setInterval(updateReadingsPerSecond, 1000);
  addNoiseControlsToUI();
  inicializarAudioContext();
  setupKeyboardShortcuts();
  setupTheme();
  setupWebSocketUrl();
  setupApiBaseUrlHelpers();
  originalChartContainer = document.querySelector("#abaGrafico .grafico-e-controles"); // Initialize originalChartContainer
  originalChartSessionControlsContainer = document.querySelector("#abaGrafico .controles-grafico-sessao"); // Initialize new variable

  // Initialize specific chart control buttons and their original parent
  originalChartControlsParent = originalChartSessionControlsContainer.querySelector(".btn-grupo");
  btnToggleLabels = document.getElementById('btn-toggle-labels');
  btnToggleDisplayMode = document.getElementById('btn-toggle-display-mode');
  btnToggleGrid = document.getElementById('btn-toggle-grid');
  btnSetSmoothLine = document.getElementById('btn-set-smooth-line');
  btnSetStraightLine = document.getElementById('btn-set-straight-line');

  // Atualiza o status dos filtros na inicializa√ß√£o
  atualizarStatusFiltros();
  // Sincroniza a apar√™ncia dos bot√µes de filtros na inicializa√ß√£o
  if (typeof syncFilterButtonsUI === 'function') {
    syncFilterButtonsUI();
  }

  // Setup para o campo de taxa de atualiza√ß√£o
  const taxaInput = document.getElementById('taxa-atualizacao');
  if (taxaInput) {
    taxaInput.value = taxaAtualizacaoMs;
    console.log('[TAXA] Campo encontrado. Valor atual:', taxaAtualizacaoMs);
    
    // Atualiza ao sair do campo
    taxaInput.addEventListener('change', (e) => {
      const novaValor = parseInt(e.target.value);
      if (!isNaN(novaValor) && novaValor >= 10 && novaValor <= 1000) {
        taxaAtualizacaoMs = novaValor;
        atualizarIntervaloAtualizacao();
        atualizarInfoTaxa();
        salvarConfiguracoesGrafico(); // Salvar automaticamente
        console.log('[TAXA] Alterada para:', taxaAtualizacaoMs, 'ms');
        showNotification('info', `Taxa de atualiza√ß√£o alterada para ${taxaAtualizacaoMs}ms (${(1000/taxaAtualizacaoMs).toFixed(1)} Hz)`);
      } else {
        e.target.value = taxaAtualizacaoMs;
        showNotification('error', 'Valor inv√°lido. Use valores entre 10 e 1000 ms.');
      }
    });
    
    // Atualiza enquanto digita (feedback em tempo real)
    taxaInput.addEventListener('input', (e) => {
      const novaValor = parseInt(e.target.value);
      if (!isNaN(novaValor) && novaValor >= 10 && novaValor <= 1000) {
        const hz = (1000 / novaValor).toFixed(1);
        const infoEl = document.getElementById('taxa-info');
        if (infoEl) {
          infoEl.textContent = `‚âà ${hz} atualiza√ß√µes/seg (pr√©via)`;
        }
      }
    });
  } else {
    console.warn('[TAXA] Campo taxa-atualizacao N√ÉO encontrado no HTML!');
  }

  // Add event listener for the new exit fullscreen button
  const exitFullscreenButton = document.getElementById('btn-exit-fullscreen');
  if (exitFullscreenButton) {
    exitFullscreenButton.addEventListener('click', toggleFullscreen);
  }

  // Setup for MAX_DATA_POINTS input
  const maxDataPointsInput = document.getElementById('max-data-points-input');
  if (maxDataPointsInput) {
    maxDataPointsInput.value = MAX_DATA_POINTS;
    maxDataPointsInput.addEventListener('change', (event) => {
      const newValue = parseInt(event.target.value);
      if (!isNaN(newValue) && newValue > 0) {
        MAX_DATA_POINTS = newValue;
        salvarConfiguracoesGrafico(); // Salvar automaticamente
        showNotification('info', 'N√∫mero m√°ximo de pontos atualizado para ' + MAX_DATA_POINTS + '.');
        // Optionally, trim existing data if new limit is smaller
        if (rawDataN.length > MAX_DATA_POINTS) {
          rawDataN = rawDataN.slice(rawDataN.length - MAX_DATA_POINTS);
          chart.updateSeries([{ data: rawDataN.map(p => [p[0], convertForce(p[1], displayUnit)]) }]);
        }
      } else {
        showNotification('error', 'Valor inv√°lido para o n√∫mero m√°ximo de pontos.');
        event.target.value = MAX_DATA_POINTS; // Revert to old value
      }
    });
  }
};

function setupTheme() {
  const themeToggle = document.getElementById('theme-toggle');
  const currentTheme = localStorage.getItem('theme') || 'light';

  if (currentTheme === 'dark') {
    document.body.classList.add('dark-mode');
    themeToggle.textContent = '‚òÄÔ∏è';
  }

  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    let theme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    themeToggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    localStorage.setItem('theme', theme);

    // Atualiza o tema do gr√°fico ApexCharts
    chart.updateOptions({
      chart: { background: 'transparent' },
      theme: { mode: theme }
    });
  });
}

function setupWebSocketUrl() {
  const wsUrlInput = document.getElementById('ws-url');
  const savedWsUrl = localStorage.getItem('wsUrl');

  if (savedWsUrl) {
    wsUrlInput.value = savedWsUrl;
  } else {
    // Se n√£o houver URL salva, preenche com o host atual e a porta padr√£o do WS
    let defaultHost = location.hostname;
    // Se estiver em um ambiente de desenvolvimento como Live Server, use localhost
    if (location.port === '5500' || defaultHost === '127.0.0.1') {
      defaultHost = 'localhost';
    }
    wsUrlInput.value = 'ws://' + defaultHost + ':81';
  }
}

// --- Gerenciamento da Taxa de Atualiza√ß√£o Din√¢mica ---

function iniciarIntervaloAtualizacao() {
  if (dataRequestIntervalId) {
    clearInterval(dataRequestIntervalId);
  }
  dataRequestIntervalId = setInterval(() => {
    if (dataWorker) {
      dataWorker.postMessage({ type: 'solicitarDados' });
    }
  }, taxaAtualizacaoMs);
  console.log(`[Intervalo] Iniciado com taxa de ${taxaAtualizacaoMs}ms (${(1000/taxaAtualizacaoMs).toFixed(1)} Hz)`);
}

function atualizarIntervaloAtualizacao() {
  if (dataRequestIntervalId) {
    clearInterval(dataRequestIntervalId);
  }
  iniciarIntervaloAtualizacao();
}

function atualizarInfoTaxa() {
  const infoEl = document.getElementById('taxa-info');
  if (infoEl) {
    const hz = (1000 / taxaAtualizacaoMs).toFixed(1);
    infoEl.textContent = `‚âà ${hz} atualiza√ß√µes/seg`;
  }
}

// --- Helpers para API HTTP (funcionam mesmo fora do host do servidor) ---
let apiBaseUrl = '';

function setupApiBaseUrlHelpers() {
  try {
    // Usa a origem atual por padr√£o
    apiBaseUrl = window.location.origin;

    // Se estiver em Live Server (porta 5500) ou arquivo local, derive do wsUrl salvo
    if (location.port === '5500' || location.protocol === 'file:') {
      const savedWsUrl = localStorage.getItem('wsUrl');
      if (savedWsUrl) {
        const { host, protocol } = parseUrlLike(savedWsUrl);
        const httpProto = protocol === 'wss:' ? 'https:' : 'http:';
        const httpPort = '80';
        // Aten√ß√£o para IPv6: se vier como ws://[addr]:81, URL() j√° retorna hostname sem colchetes
        apiBaseUrl = `${httpProto}//${host}:${httpPort}`;
      }
    }
  } catch (e) {
    console.warn('setupApiBaseUrlHelpers fallback para origem atual:', e);
    apiBaseUrl = window.location.origin;
  }
}

function parseUrlLike(urlStr) {
  try {
    let u = urlStr.trim();
    if (!u.startsWith('ws://') && !u.startsWith('wss://') && !u.startsWith('http')) {
      u = 'ws://' + u;
    }
    const url = new URL(u);
    return { protocol: url.protocol, host: url.hostname, port: url.port };
  } catch (e) {
    return { protocol: 'http:', host: location.hostname, port: '' };
  }
}

async function apiFetch(path, options = {}) {
  // Primeiro tenta relativo (mesma origem). Se falhar por erro de rede, tenta apiBaseUrl
  try {
    const res = await fetch(path, options);
    return res;
  } catch (e) {
    try {
      const url = path.startsWith('/') ? apiBaseUrl + path : apiBaseUrl + '/' + path;
      return await fetch(url, options);
    } catch (e2) {
      throw e2;
    }
  }
}

// --- Inicializa√ß√£o e Controle do Gr√°fico (ApexCharts) ---

function initializeApexChart() {
  const currentTheme = localStorage.getItem('theme') || 'light';
  const options = {
    series: [{
      name: 'For√ßa',
      data: []
    }],
    chart: {
      id: 'realtime',
      height: 450,
      type: 'line',
      animations: {
        enabled: true,
        easing: 'linear',
        dynamicAnimation: {
          speed: 400
        }
      },
      toolbar: {
        show: true
      },
      zoom: {
        enabled: true
      },
      background: 'transparent'
    },
    grid: {
      show: true,
      borderColor: '#90A4AE',
      strokeDashArray: 4,
      xaxis: {
        lines: {
          show: true
        }
      },
      yaxis: {
        lines: {
          show: true
        }
      },
      row: {
        colors: ['#f3f3f3', 'transparent'], // alternating row colors
        opacity: 0.5
      },
      column: {
        colors: ['#f3f3f3', 'transparent'], // alternating column colors
        opacity: 0.5
      }
    },
    stroke: {
      curve: 'smooth',
      width: chartDisplayMode === 'line' || chartDisplayMode === 'both' ? 2.5 : 0
    },
    xaxis: {
      type: 'numeric',
      tickAmount: 10,
      labels: {
        formatter: (val) => {
          if (val % 1 === 0) {
            return parseInt(val) + 's';
          } else {
            return val.toFixed(1) + 's';
          }
        }
      }
    },
    yaxis: {
      labels: {
        formatter: (val) => {
          if (Math.abs(val) < 0.001) return '0.000 ' + displayUnit;
          if (Math.abs(val) < 0.01) return val.toFixed(4) + ' ' + displayUnit;
          if (Math.abs(val) < 0.1) return val.toFixed(3) + ' ' + displayUnit;
          if (Math.abs(val) < 10) return val.toFixed(2) + ' ' + displayUnit;
          return val.toFixed(1) + ' ' + displayUnit;
        }
      }
    },
    dataLabels: {
      enabled: false,
      offsetY: -10,
      style: {
        fontSize: '10px',
      },
    },
    markers: {
      size: chartDisplayMode === 'points' || chartDisplayMode === 'both' ? 4 : 0,
      colors: ['#FF0000']
    },
    theme: {
      mode: currentTheme
    }
  };

  chart = new ApexCharts(document.querySelector("#grafico"), options);
  chart.render();
}

function clearChart() {
  maxForceInN = -Infinity;
  minForceInN = Infinity;
  rawDataN = [];
  chart.updateSeries([{ data: [] }]);
  updateAccumulatedPointsDisplay(); // Atualiza o contador para 0
  showNotification("info", "Gr√°fico limpo. (Atalho: L)", 3000);
}

function setDisplayUnit(unit) {
  displayUnit = unit;
  document.querySelectorAll('#btn-unit-n, #btn-unit-gf, #btn-unit-kgf').forEach(b => b.classList.remove('ativo'));
  document.getElementById(`btn-unit-${unit.toLowerCase()}`).classList.add('ativo');

  // Salvar configura√ß√£o automaticamente
  salvarConfiguracoesGrafico();

  // Re-processa os dados existentes para a nova unidade
  const newData = rawDataN.map(point => {
    return [point[0], convertForce(point[1], displayUnit)];
  });

  chart.updateSeries([{
    data: newData
  }]);

  chart.updateOptions({
    yaxis: {
      labels: {
        formatter: (val) => val.toFixed(3) + ' ' + displayUnit
      }
    }
  });
}

function setChartMode(mode) {
  // Salva se estava no modo acumulado antes de mudar
  if (chartMode === 'acumulado') {
    wasAccumulating = true;
  } else if (mode === 'deslizante') {
    // Se voltar para deslizante, reseta o flag
    wasAccumulating = false;
  }
  
  chartMode = mode;
  document.querySelectorAll('#btn-deslizante, #btn-acumulado, #btn-pausado').forEach(b => b.classList.remove('ativo'));
  document.getElementById(`btn-${mode}`).classList.add('ativo');
  isChartPaused = (mode === 'pausado');
  
  // Salvar configura√ß√£o automaticamente
  salvarConfiguracoesGrafico();
  
  const maxPointsInput = document.getElementById('max-data-points-input');
  const maxPointsLabel = document.getElementById('max-data-points-label');
  
  if (mode === 'acumulado' || (mode === 'pausado' && wasAccumulating)) {
    // No modo acumulado ou pausado ap√≥s acumular, desabilita o input e mostra a contagem atual
    maxPointsInput.disabled = true;
    maxPointsInput.style.fontWeight = 'bold';
    maxPointsInput.style.color = 'var(--cor-info)';
    if (maxPointsLabel) {
      if (mode === 'pausado') {
        maxPointsLabel.textContent = '‚è∏Ô∏è Pontos Acumulados (Pausado):';
      } else {
        maxPointsLabel.textContent = 'üìä Pontos Acumulados:';
      }
      maxPointsLabel.style.color = 'var(--cor-info)';
      maxPointsLabel.style.fontWeight = 'bold';
    }
    updateAccumulatedPointsDisplay();
  } else {
    // Nos outros modos, habilita o input normalmente
    maxPointsInput.disabled = false;
    maxPointsInput.style.fontWeight = 'normal';
    maxPointsInput.style.color = '';
    maxPointsInput.value = MAX_DATA_POINTS;
    if (maxPointsLabel) {
      maxPointsLabel.textContent = 'Max Pontos:';
      maxPointsLabel.style.color = '';
      maxPointsLabel.style.fontWeight = 'normal';
    }
  }
}

function updateAccumulatedPointsDisplay() {
  if (chartMode === 'acumulado' || (chartMode === 'pausado' && wasAccumulating)) {
    const maxPointsInput = document.getElementById('max-data-points-input');
    if (maxPointsInput) {
      maxPointsInput.value = rawDataN.length;
    }
  }
}

function toggleChartPause(setPaused = null) {
  if (setPaused !== null) {
    isChartPaused = false;
  }
  if (isChartPaused) {
    setChartMode('deslizante');
    showNotification('info', 'Gr√°fico retomado (Deslizante). (Atalho: P)');
  } else {
    setChartMode('pausado');
    showNotification('info', 'Gr√°fico pausado. (Atalho: P)');
  }
}

// --- Comunica√ß√£o com o Web Worker ---

/**
 * Conex√£o r√°pida do worker - chamada assim que o DOM come√ßa a carregar
 * N√£o aguarda window.onload para iniciar a conex√£o WebSocket
 */
function conectarWorkerRapido() {
  if (window.Worker) {
    if (!dataWorker) {
      dataWorker = new Worker('dataWorker.js');
      dataWorker.onmessage = handleWorkerMessage;
      
      // Envia a URL do WebSocket IMEDIATAMENTE
      const savedWsUrl = localStorage.getItem('wsUrl');
      if (savedWsUrl) {
        dataWorker.postMessage({ type: 'set_ws_url', payload: { url: savedWsUrl } });
      } else {
        // Construir URL padr√£o mesmo sem localStorage (acelera primeira conex√£o)
        let defaultHost = location.hostname;
        if (location.port === '5500' || defaultHost === '127.0.0.1') {
          defaultHost = 'localhost';
        }
        const defaultUrl = 'ws://' + defaultHost + ':81';
        dataWorker.postMessage({ type: 'set_ws_url', payload: { url: defaultUrl } });
      }
      
      // OTIMIZA√á√ÉO: Taxa de atualiza√ß√£o mais r√°pida e agressiva na inicializa√ß√£o
      // Come√ßa com 50ms para melhor responsividade inicial
      taxaAtualizacaoMs = 50;
      setInterval(() => dataWorker.postMessage({ type: 'solicitarDados' }), taxaAtualizacaoMs);
      
      console.log('[Worker] Conectado com taxa inicial de 50ms para responsividade');
    }
  } else {
    showNotification('error', 'Seu navegador n√£o suporta Web Workers.');
  }
}

function conectarWorker() {
  if (window.Worker) {
    if (!dataWorker) {
      dataWorker = new Worker('dataWorker.js');
      dataWorker.onmessage = handleWorkerMessage;
      const savedWsUrl = localStorage.getItem('wsUrl');
      if (savedWsUrl) {
        dataWorker.postMessage({ type: 'set_ws_url', payload: { url: savedWsUrl } });
      }
      setInterval(() => dataWorker.postMessage({ type: 'solicitarDados' }), 200);
    }
  } else {
    showNotification('error', 'Seu navegador n√£o suporta Web Workers.');
  }
}

function handleWorkerMessage(event) {
  const { type, payload, status, message } = event.data;
  let currentSessionId = null; // Declare it here
  let notificationMessage = message; // Use a new variable for notification message

  // Extract sessionId and update notificationMessage for specific cases
  if (type === 'mysql_save_success' || type === 'mysql_save_error') {
    currentSessionId = payload.sessionId;
    notificationMessage = payload.message; // Update message for notification
  }

  switch (type) {
    case 'dadosDisponiveis':
      payload.forEach(updateUIFromData);
      break;
    case 'rps':
      document.getElementById('leituras-por-segundo').textContent = payload;
      break;
    case 'config':
      console.log('Configura√ß√£o recebida:', payload);
      updateConfigForm(payload);
      break;
    case 'status':
      document.getElementById('balanca-status').textContent = notificationMessage || status; // Use notificationMessage
      if (status === 'connected' || status === 'disconnected') {
        updateConnectionStatus(status === 'connected');
      }
      if (notificationMessage) { // Use notificationMessage
        const notificationType = (status === 'error' || status === 'disconnected') ? 'error' : 'info';
        showNotification(notificationType, notificationMessage);
      }
      verificarStatusEstabilizacao(notificationMessage); // Use notificationMessage
      break;
    case 'mysql_status_update': // NEW: Handle MySQL status updates
      isMysqlConnected = payload;
      updateMysqlIndicator(isMysqlConnected);
      break;
    case 'mysql_save_success':
      showNotification('success', `Sess√£o "${notificationMessage}" salva no MySQL!`); // Use notificationMessage
      loadAndDisplayAllSessions(); // Re-render the list
      break;
    case 'mysql_save_error':
      showNotification('error', `Erro ao salvar sess√£o "${notificationMessage}" no MySQL.`); // Use notificationMessage
      break;
    case 'debug':
      console.log("[Worker Debug]:", message);
      break;
    default:
      console.warn("Mensagem desconhecida do worker:", event.data);
  }
}

// NEW: Function to update the MySQL UI indicator
function updateMysqlIndicator(connected) {
  const indicator = document.getElementById('mysql-indicator');
  const textElement = document.getElementById('mysql-text');
  if (indicator) {
    indicator.className = 'status-indicator ' + (connected ? 'conectado' : 'desconectado');
    indicator.title = connected ? 'MySQL Conectado' : 'MySQL Desconectado';
  }
  if (textElement) {
    textElement.textContent = connected ? 'Conectado' : 'Desconectado';
  }
}

function sendCommandToWorker(command, value = null) {
  if (!dataWorker) {
    showNotification("error", "Worker n√£o est√° conectado.");
    return;
  }
  // NEW: Always send a JSON object as payload to the worker
  const messagePayload = { cmd: command };
  if (value !== null) {
    // For 'save_session_to_mysql', value is the entire session object
    if (command === 'save_session_to_mysql') {
      messagePayload.sessionData = value;
    } else {
      // For other commands, value is a simple parameter
      messagePayload.value = value;
    }
  }
  dataWorker.postMessage({ type: 'sendCommand', payload: messagePayload });
}

// --- Atualiza√ß√£o da UI ---

function updateUIFromData(dado) {
  if (isChartPaused) return;

  let { tempo, forca, ema } = dado;

  // === PIPELINE DE FILTROS ===
  // Ordem cr√≠tica: Zona Morta ‚Üí Arredondamento ‚Üí Anti-Noising
  // Zona morta remove valores dentro da margem de erro da c√©lula (neutraliza√ß√£o)
  
  // [1] Converter for√ßa de Newtons para gramas (base de c√°lculo de zona morta)
  // [2] Aplicar zona morta + arredondamento inteligente
  // [3] Converter de volta para Newtons
  const forcaGramas = (forca / 9.80665) * 1000;
  const forcaGramasFiltrada = aplicarFiltrosGramas(forcaGramas);
  forca = (forcaGramasFiltrada / 1000) * 9.80665;

  // Aplicar MESMOS filtros no EMA para manter consist√™ncia
  // O EMA √© uma m√©dia m√≥vel exponencial que tamb√©m sofre com a imprecis√£o da c√©lula
  // Sem zona morta aqui, o gr√°fico EMA mostraria oscila√ß√µes indesejadas
  const emaGramas = (ema / 9.80665) * 1000;
  const emaGramasFiltrada = aplicarFiltrosGramas(emaGramas);
  ema = (emaGramasFiltrada / 1000) * 9.80665;

  // Anti-noising aplicado POR √öLTIMO (ap√≥s zona morta j√° ter neutralizado o ru√≠do)
  // Evita amplificar artefatos que j√° foram filtrados
  let forcaFiltrada = antiNoisingAtivo ? applyAntiNoising(forca) : forca;

  if (isStabilityMode) {
    calculateNoiseStatistics(forca);
  }

  if (forcaFiltrada > maxForceInN) maxForceInN = forcaFiltrada;
  if (forcaFiltrada < minForceInN) minForceInN = forcaFiltrada;

  const displayForce = convertForce(forcaFiltrada, displayUnit);
  const maxDisplayForce = convertForce(maxForceInN, displayUnit);
  const minDisplayForce = convertForce(minForceInN, displayUnit);
  const emaDisplay = convertForce(ema, displayUnit);

  document.getElementById('forca-atual').textContent = displayForce.toFixed(3);
  document.getElementById('forca-ems').textContent = emaDisplay.toFixed(3);
  document.getElementById('forca-maxima').textContent = maxDisplayForce.toFixed(3);
  document.getElementById('forca-minima').textContent = 'm√≠n: ' + minDisplayForce.toFixed(3);

  // Calcula percentual para alertas
  const capacidadeGramas = parseFloat(document.getElementById("param-capacidade-maxima")?.value) || 5000;
  const capacidadeN = (capacidadeGramas / 1000) * 9.80665;
  const percentual = Math.abs((forcaFiltrada / capacidadeN) * 100);

  // Aplica alertas graduais de limite da c√©lula
  aplicarAlertasLimite(forcaFiltrada);
  
  // Atualiza barra de progresso do esfor√ßo no display (passa for√ßa e percentual)
  atualizarBarraEsforcoDisplay(percentual, forcaFiltrada);
  
  // Verifica e atualiza modal de sobrecarga (80%+)
  verificarModalSobrecarga(forcaFiltrada, percentual);

  rawDataN.push([tempo, forcaFiltrada]);

  // No modo deslizante, mant√©m apenas os √∫ltimos MAX_DATA_POINTS
  // No modo acumulado, mant√©m todos os dados
  if (chartMode === 'deslizante' && rawDataN.length > MAX_DATA_POINTS) {
    rawDataN.shift();
  }

  // Adiciona o novo ponto ao buffer de atualiza√ß√£o do gr√°fico
  chartUpdateBuffer.push([tempo, forcaFiltrada]);

  // Se n√£o houver uma atualiza√ß√£o de quadro de anima√ß√£o agendada, agende uma
  if (!animationFrameId) {
    animationFrameId = requestAnimationFrame(processChartUpdates);
  }

  if (isSessionActive) {
    const tbody = document.getElementById("tabela").querySelector("tbody");
    const linha = tbody.insertRow(0);
  // Gera timestamp em GMT (UTC) no formato dd/mm/yyyy HH:MM:SS.mmm
  const agora = new Date();
  const dd = String(agora.getUTCDate()).padStart(2, '0');
  const mm = String(agora.getUTCMonth() + 1).padStart(2, '0');
  const yyyy = agora.getUTCFullYear();
  const HH = String(agora.getUTCHours()).padStart(2, '0');
  const MM = String(agora.getUTCMinutes()).padStart(2, '0');
  const SS = String(agora.getUTCSeconds()).padStart(2, '0');
  const mmm = String(agora.getUTCMilliseconds()).padStart(3, '0');
  const timestamp = `${dd}/${mm}/${yyyy} ${HH}:${MM}:${SS}.${mmm}`;

  linha.insertCell(0).innerText = timestamp;
  linha.insertCell(1).innerText = Number(tempo).toFixed(3);
  linha.insertCell(2).innerText = Number(forcaFiltrada).toFixed(6);
  linha.insertCell(3).innerText = Number((forcaFiltrada / 9.80665) * 1000).toFixed(casasDecimais);
  linha.insertCell(4).innerText = Number(forcaFiltrada / 9.80665).toFixed(6);

    if (tbody.rows.length > 5000) {
      tbody.deleteRow(tbody.rows.length - 1);
    }
  }
}

function processChartUpdates() {
  if (chartUpdateBuffer.length === 0) {
    animationFrameId = null;
    return;
  }

  // Converte todos os pontos do buffer para a unidade de exibi√ß√£o
  const displayData = rawDataN.map(p => [p[0], convertForce(p[1], displayUnit)]);

  // Atualiza o gr√°fico uma √∫nica vez com todos os dados acumulados
  chart.updateSeries([{ data: displayData }]);
  
  // Atualiza o contador de pontos se estiver no modo acumulado
  updateAccumulatedPointsDisplay();

  // Limpa o buffer e redefine o ID do quadro de anima√ß√£o
  chartUpdateBuffer = [];
  animationFrameId = null;
}

function updateConnectionStatus(isConnected) {
  const indicator = document.getElementById('ws-indicator');
  const text = document.getElementById('ws-text');
  document.body.classList.toggle('desconectado', !isConnected);
  indicator.classList.toggle('conectado', isConnected);
  indicator.title = isConnected ? 'Conectado' : 'Desconectado';
  if (text) text.textContent = isConnected ? 'Conectado' : 'Desconectado';
  if (isConnected) tocarAlertaReconexao(); else tocarAlertaDesconexao();
}

function updateReadingsPerSecond() {
  if (dataWorker) {
    dataWorker.postMessage({ type: 'getRPS' });
  }
}

function updateConfigForm(config) {
  const getValue = (val) => (val !== null && val !== undefined) ? val : '';
  document.getElementById("param-conversao").value = getValue(config.conversionFactor);
  document.getElementById("param-gravidade").value = getValue(config.gravity);
  document.getElementById("param-offset").value = getValue(config.tareOffset);
  document.getElementById("param-leituras-estaveis").value = getValue(config.leiturasEstaveis);
  document.getElementById("param-tolerancia").value = getValue(config.toleranciaEstabilidade);
  document.getElementById("param-num-amostras").value = getValue(config.numAmostrasMedia);
  document.getElementById("param-timeout").value = getValue(config.timeoutCalibracao);
  document.getElementById("param-capacidade-maxima").value = getValue(config.capacidadeMaximaGramas);
  document.getElementById("param-acuracia").value = getValue(config.percentualAcuracia);

  // Valida√ß√£o robusta com logs para debug
  const novaCapacidade = parseFloat(config.capacidadeMaximaGramas);
  const novaAcuracia = parseFloat(config.percentualAcuracia);
  const novaTol = parseFloat(config.toleranciaEstabilidade);
  const novoTimeout = parseFloat(config.timeoutCalibracao);
  
  capacidadeMaximaGramas = (!isNaN(novaCapacidade) && novaCapacidade > 0) ? novaCapacidade : 5000.0;
  percentualAcuracia = (!isNaN(novaAcuracia) && novaAcuracia > 0) ? novaAcuracia : 0.05;

  console.log('[updateConfigForm] Valores recebidos do ESP:');
  console.log('  Capacidade:', config.capacidadeMaximaGramas, '‚Üí', capacidadeMaximaGramas);
  console.log('  Acur√°cia:', config.percentualAcuracia, '‚Üí', percentualAcuracia);
  console.log('  Toler√¢ncia:', config.toleranciaEstabilidade, '‚Üí', novaTol.toFixed(2));
  console.log('  Timeout (ms):', config.timeoutCalibracao, '‚Üí', novoTimeout.toFixed(0));
  console.log('  Erro Absoluto calculado:', (capacidadeMaximaGramas * percentualAcuracia).toFixed(2), 'g');

  atualizarToleranciaEmGramas();
  atualizarCapacidadeEmKg();
  atualizarErroAbsoluto();
  atualizarStatusFiltros();

  // Remove loading class after updating form
  document.getElementById('abaControles').classList.remove('config-loading');
}

// --- Fun√ß√µes de A√ß√£o do Usu√°rio ---

function tare() {
  sendCommandToWorker("t");
  showNotification('info', 'Comando de Tara enviado. (Atalho: Shift + T)');
  // Request config update after tare
  setTimeout(() => sendCommandToWorker('get_config'), 1000);
}

function calibrar() {
  const massa = parseFloat(document.getElementById("massaCalibracao").value);
  if (!isNaN(massa) && massa > 0) {
    sendCommandToWorker("c", massa);
    showNotification('info', 'Comando de calibra√ß√£o com ' + massa + 'g enviado. (Atalho: Shift + C)');
    // Request config update after calibration
    setTimeout(() => sendCommandToWorker('get_config'), 1000);
  } else {
    showNotification("error", "Informe uma massa de calibra√ß√£o v√°lida.");
  }
}

async function salvarParametros() {
  const params = {
    conversionFactor: "param-conversao", gravity: "param-gravidade",
    tareOffset: "param-offset", leiturasEstaveis: "param-leituras-estaveis",
    toleranciaEstabilidade: "param-tolerancia", numAmostrasMedia: "param-num-amostras",
    timeoutCalibracao: "param-timeout", capacidadeMaximaGramas: "param-capacidade-maxima",
    percentualAcuracia: "param-acuracia",
  };

  showNotification('info', 'Enviando par√¢metros para o dispositivo...');

  for (const [key, id] of Object.entries(params)) {
    const valueStr = document.getElementById(id).value.trim();
    if (valueStr !== '') {
      const valueNum = parseFloat(valueStr.replace(',', '.'));
      if (!isNaN(valueNum)) {
        // Envia um comando de cada vez com um pequeno atraso
        await new Promise(resolve => setTimeout(resolve, 100));
        // Usa o protocolo padronizado do worker: cmd 'set' com objeto {param, value}
        sendCommandToWorker('set', { param: key, value: valueNum });
      }
    }
  }

  // Ap√≥s enviar todos os comandos, espera um pouco e solicita a configura√ß√£o atualizada
  setTimeout(() => {
    showNotification('success', 'Par√¢metros salvos! Atualizando valores...');
    sendCommandToWorker('get_config');
  }, 1000); // Espera 1 segundo
}

function salvarWsUrl() {
  const wsUrl = document.getElementById('ws-url').value;
  localStorage.setItem('wsUrl', wsUrl);
  if (dataWorker) {
    dataWorker.postMessage({ type: 'set_ws_url', payload: { url: wsUrl } });
  }
  showNotification('success', 'URL do WebSocket salva. A conex√£o ser√° reiniciada.');
}

function resetarWsUrl() {
  // Remove a URL salva do localStorage
  localStorage.removeItem('wsUrl');
  
  // Obt√©m o host padr√£o (hostname atual da p√°gina)
  const defaultHost = window.location.hostname || 'localhost';
  const defaultWsUrl = 'ws://' + defaultHost + ':81';
  
  // Atualiza o campo de input
  const wsUrlInput = document.getElementById('ws-url');
  wsUrlInput.value = defaultWsUrl;
  
  // Reinicia a conex√£o com o padr√£o
  if (dataWorker) {
    dataWorker.postMessage({ type: 'set_ws_url', payload: { url: defaultWsUrl } });
  }
  
  showNotification('success', 'URL do WebSocket restaurada para o padr√£o: ' + defaultWsUrl);
}

// --- Fun√ß√µes de Sess√£o ---

function iniciarSessao() {
  const nomeSessaoInput = document.getElementById('nome-sessao');
  if (!nomeSessaoInput.value.trim()) {
    showNotification('error', 'Por favor, insira um nome para a sess√£o.');
    nomeSessaoInput.focus();
    return;
  }
  clearChart();
  document.getElementById("tabela").querySelector("tbody").innerHTML = '';
  isSessionActive = true;
  showNotification('success', 'Sess√£o "' + nomeSessaoInput.value + '" iniciada.');
  document.getElementById('btn-iniciar-sessao').disabled = true;
  nomeSessaoInput.disabled = true;
  document.getElementById('btn-encerrar-sessao').disabled = false;
}

async function encerrarSessao() {
  if (!isSessionActive) return;
  const nomeSessao = document.getElementById('nome-sessao').value.trim();
  const tabela = document.getElementById("tabela").querySelector("tbody");
  if (tabela.rows.length > 0) {
    const gravacao = await salvarDadosDaSessao(nomeSessao, tabela); // Modified to await
    if (gravacao && isMysqlConnected) {
      showNotification('info', 'Enviando sess√£o "' + gravacao.nome + '" para o MySQL...');
      sendCommandToWorker('save_session_to_mysql', gravacao); // Save to DB via worker
    }
  } else {
    showNotification('info', 'Nenhum dado foi gravado. Nada foi salvo.');
  }
  isSessionActive = false;
  const nomeSessaoInput = document.getElementById('nome-sessao');
  document.getElementById('btn-iniciar-sessao').disabled = false;
  nomeSessaoInput.disabled = false;
  nomeSessaoInput.value = '';
  document.getElementById('btn-encerrar-sessao').disabled = true;
}

async function salvarDadosDaSessao(nome, tabela) {
  const dadosTabela = Array.from(tabela.rows).map(linha => ({
    timestamp: linha.cells[0].innerText,
    tempo_esp: linha.cells[1].innerText,
    newtons: linha.cells[2].innerText,
    grama_forca: linha.cells[3].innerText,
    quilo_forca: linha.cells[4].innerText
  })).reverse();

  const metadadosMotor = {
    name: (document.getElementById('eng-name')?.value?.trim() || nome.replace(/[^a-zA-Z0-9_]/g, '_')),
    diameter: parseFloat(document.getElementById('eng-diameter')?.value) || 45,
    length: parseFloat(document.getElementById('eng-length')?.value) || 200,
    delay: parseFloat(document.getElementById('eng-delay')?.value) || 0,
    propweight: parseFloat(document.getElementById('eng-propweight')?.value) || 0.1,
    totalweight: parseFloat(document.getElementById('eng-totalweight')?.value) || 0.25,
    manufacturer: (document.getElementById('eng-manufacturer')?.value?.trim() || 'GFIG-IFC'),
    massaPropelente: parseFloat(document.getElementById('massa-propelente-input')?.value) || null // Massa em gramas
  };

  const gravacao = {
    id: Date.now(),
    nome,
    timestamp: new Date().toISOString(),
    data_modificacao: new Date().toISOString(),
    dadosTabela,
    metadadosMotor,
    savedToMysql: isMysqlConnected // Mark as saved to MySQL if connected
  };

  try {
    let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
    gravacoes.push(gravacao);
    localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
    showNotification('success', 'Sess√£o "' + nome + '" salva localmente!');
    return gravacao; // Return the saved session
  } catch (e) {
    showNotification('error', 'Erro ao salvar. O Local Storage pode estar cheio.');
    return null;
  }
}

// --- Fun√ß√µes Auxiliares e de UI ---

function abrirAba(element, abaID) {
  document.querySelectorAll('.tabcontent').forEach(tab => { tab.style.display = "none"; tab.classList.remove('active'); });
  document.querySelectorAll('.tablink').forEach(link => link.classList.remove('active'));
  const el = document.getElementById(abaID);
  if (abaID === 'abaControles') {
    el.classList.add('config-loading'); // Add loading class
    sendCommandToWorker('get_config');
  } else if (abaID === 'abaGravacoes') {
    loadAndDisplayAllSessions(); // Load all sessions (local and DB)
  }
  el.style.display = "block";
  el.classList.add('active');
  element.classList.add('active');
}

function showNotification(type, message, duration = 5000) {
  const area = document.getElementById('notification-area');
  const notification = document.createElement('div');
  notification.className = 'notification ' + type;
  notification.innerHTML = message;
  area.prepend(notification);
  setTimeout(() => {
    notification.style.transition = 'opacity 0.5s';
    notification.style.opacity = '0';
    setTimeout(() => notification.remove(), 500);
  }, duration);
}

function convertForce(valueN, unit) {
  const g_force_conversion = 101.9716;
  if (unit === 'gf') return valueN * g_force_conversion;
  if (unit === 'kgf') return valueN * (g_force_conversion / 1000);
  return valueN;
}

/**
 * Aplica classes de alerta gradual nos cards do display baseado na proximidade do limite
 * @param {number} forcaAtualN - For√ßa atual em Newtons
 */
function aplicarAlertasLimite(forcaAtualN) {
  // Obt√©m a capacidade m√°xima em gramas e converte para Newtons
  const capacidadeGramas = parseFloat(document.getElementById("param-capacidade-maxima")?.value) || 5000;
  const capacidadeN = (capacidadeGramas / 1000) * 9.80665; // Converte kg para N
  
  // Calcula o percentual em rela√ß√£o √† capacidade m√°xima (usa valor absoluto)
  const percentual = Math.abs((forcaAtualN / capacidadeN) * 100);
  
  // Seleciona todos os cards de leitura
  const cards = document.querySelectorAll('.leituras-valores > div');
  
  // Remove todas as classes de alerta existentes
  cards.forEach(card => {
    card.classList.remove('alerta-70', 'alerta-80', 'alerta-90', 'alerta-limite');
  });
  
  // Aplica a classe apropriada baseada no percentual
  if (percentual >= 100) {
    // Limite excedido - vermelho intenso com pulsa√ß√£o r√°pida
    cards.forEach(card => card.classList.add('alerta-limite'));
  } else if (percentual >= 90) {
    // 90-99% - vermelho com pulsa√ß√£o suave
    cards.forEach(card => card.classList.add('alerta-90'));
  } else if (percentual >= 80) {
    // 80-89% - laranja
    cards.forEach(card => card.classList.add('alerta-80'));
  } else if (percentual >= 70) {
    // 70-79% - amarelo
    cards.forEach(card => card.classList.add('alerta-70'));
  }
  // Abaixo de 70% n√£o aplica nenhuma classe (mant√©m estilo normal)
}

/**
 * Controla a exibi√ß√£o do modal de alerta de sobrecarga
 * @param {number} forcaAtualN - For√ßa atual em Newtons
 * @param {number} percentual - Percentual da capacidade
 */
let modalSobrecargaAberto = false;
let ultimoNivelAlerta = 0;
let modalFechadoPeloUsuario = false; // Flag para controlar se usu√°rio fechou manualmente
let timestampFechamentoManual = 0; // Timestamp do fechamento manual

function verificarModalSobrecarga(forcaAtualN, percentual) {
  const modal = document.getElementById('modal-alerta-sobrecarga');
  const modalContent = modal.querySelector('.modal-sobrecarga-content');
  const titulo = document.getElementById('modal-sobrecarga-titulo');
  const mensagem = document.getElementById('modal-sobrecarga-mensagem');
  
  // Obt√©m a capacidade m√°xima em gramas e converte para Newtons
  const capacidadeGramas = parseFloat(document.getElementById("param-capacidade-maxima")?.value) || 5000;
  const capacidadeN = (capacidadeGramas / 1000) * 9.80665;
  
  // Converte valores para a unidade atual do display
  const valorAtual = convertForce(Math.abs(forcaAtualN), displayUnit);
  const valorLimite = convertForce(capacidadeN, displayUnit);
  
  // Atualiza os valores no modal
  document.getElementById('modal-sobrecarga-valor-atual').textContent = 
    valorAtual.toFixed(3) + ' ' + displayUnit;
  document.getElementById('modal-sobrecarga-valor-limite').textContent = 
    valorLimite.toFixed(3) + ' ' + displayUnit;
  document.getElementById('modal-sobrecarga-percentual').textContent = 
    percentual.toFixed(1) + '%';
  
  // Atualiza a barra de progresso
  const barra = document.getElementById('modal-sobrecarga-barra-progresso');
  barra.style.width = Math.min(percentual, 100) + '%';
  
  // Define o n√≠vel de alerta atual
  let nivelAtual = 0;
  if (percentual >= 100) nivelAtual = 100;
  else if (percentual >= 90) nivelAtual = 90;
  else if (percentual >= 80) nivelAtual = 80;
  
  // Se o modal foi fechado manualmente, s√≥ reabre ap√≥s 10 segundos OU se a carga cair abaixo de 70%
  const tempoDesdeFechar = Date.now() - timestampFechamentoManual;
  if (modalFechadoPeloUsuario && percentual < 70) {
    // Reset da flag se a carga caiu significativamente
    modalFechadoPeloUsuario = false;
    timestampFechamentoManual = 0;
  } else if (modalFechadoPeloUsuario && tempoDesdeFechar < 10000) {
    // N√£o reabre se ainda n√£o passou 10 segundos
    return;
  }
  
  // Abre o modal se passar de 80% e n√£o estiver aberto
  if (percentual >= 80 && !modalSobrecargaAberto) {
    modal.classList.add('ativo');
    modalSobrecargaAberto = true;
    modalFechadoPeloUsuario = false; // Reset ao abrir automaticamente
    ultimoNivelAlerta = nivelAtual;
    
    // Toca som de alerta se dispon√≠vel
    try {
      const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFApGn+DyvmwhBjeR1/LMeSwFJHfH8N2RQAoUXrTp66hVFA==');
      audio.play().catch(() => {});
    } catch (e) {}
  }
  
  // Atualiza as classes visuais do modal conforme o n√≠vel
  if (modalSobrecargaAberto) {
    modalContent.classList.remove('alerta-80', 'alerta-90', 'alerta-100');
    
    if (percentual >= 100) {
      modalContent.classList.add('alerta-100');
      titulo.textContent = 'üö® LIMITE EXCEDIDO! PARE IMEDIATAMENTE! üö®';
      mensagem.innerHTML = `
        ‚õî <strong>LIMITE DA C√âLULA ULTRAPASSADO!</strong><br>
        <strong style="font-size: 1.15rem; color: #7f1d1d;">RISCO CR√çTICO DE DESTRUI√á√ÉO DO EQUIPAMENTO!</strong>
      `;
    } else if (percentual >= 90) {
      modalContent.classList.add('alerta-90');
      titulo.textContent = 'üö® PERIGO: MUITO PR√ìXIMO DO LIMITE! üö®';
      mensagem.innerHTML = `
        ‚ö†Ô∏è Voc√™ est√° em zona cr√≠tica!<br>
        <strong>RISCO IMINENTE DE DANOS PERMANENTES!</strong>
      `;
    } else if (percentual >= 80) {
      modalContent.classList.add('alerta-80');
      titulo.textContent = '‚ö†Ô∏è ATEN√á√ÉO: APROXIMANDO DO LIMITE! ‚ö†Ô∏è';
      mensagem.innerHTML = `
        ‚ö†Ô∏è Voc√™ est√° pr√≥ximo do limite da c√©lula de carga!<br>
        <strong>RISCO DE DANOS PERMANENTES AO EQUIPAMENTO!</strong>
      `;
    }
    
    // Fecha automaticamente se cair abaixo de 75% (mas n√£o marca como fechado pelo usu√°rio)
    if (percentual < 75) {
      fecharModalSobrecarga(false); // false = fechamento autom√°tico
    }
  }
}

function fecharModalSobrecarga(fechadoPeloUsuario = true) {
  const modal = document.getElementById('modal-alerta-sobrecarga');
  modal.classList.remove('ativo');
  modalSobrecargaAberto = false;
  ultimoNivelAlerta = 0;
  
  // Se foi fechado pelo usu√°rio (clique no bot√£o), marca a flag
  if (fechadoPeloUsuario) {
    modalFechadoPeloUsuario = true;
    timestampFechamentoManual = Date.now();
    console.log('[MODAL] Fechado pelo usu√°rio - n√£o reabrir√° por 10 segundos ou at√© carga cair abaixo de 70%');
  }
}

/**
 * Atualiza a barra de progresso do esfor√ßo da c√©lula no display
 * @param {number} percentual - Percentual da capacidade
 * @param {number} forcaAtualN - For√ßa atual em Newtons
 */
function atualizarBarraEsforcoDisplay(percentual, forcaAtualN) {
  const barraFill = document.getElementById('barra-esforco-fill');
  const barraTexto = document.getElementById('barra-esforco-texto');
  
  if (!barraFill || !barraTexto) return;
  
  // Converte para a unidade atual do display
  const valorDisplay = convertForce(Math.abs(forcaAtualN), displayUnit);
  
  // Atualiza largura da barra
  barraFill.style.width = Math.min(percentual, 100) + '%';
  
  // Atualiza texto dentro da barra (valor | percentual)
  barraTexto.textContent = `${valorDisplay.toFixed(2)} ${displayUnit} | ${percentual.toFixed(1)}%`;
  
  // Remove todas as classes anteriores
  barraFill.classList.remove('nivel-50', 'nivel-60', 'nivel-70', 'nivel-80', 'nivel-90', 'nivel-100');
  
  // Aplica classe conforme o n√≠vel (iniciando em 50%)
  if (percentual >= 100) {
    barraFill.classList.add('nivel-100');
  } else if (percentual >= 90) {
    barraFill.classList.add('nivel-90');
  } else if (percentual >= 80) {
    barraFill.classList.add('nivel-80');
  } else if (percentual >= 70) {
    barraFill.classList.add('nivel-70');
  } else if (percentual >= 60) {
    barraFill.classList.add('nivel-60');
  } else if (percentual >= 50) {
    barraFill.classList.add('nivel-50');
  }
  // Abaixo de 50% mant√©m o verde padr√£o
}

function atualizarToleranciaEmGramas() {
  const toleranciaBruta = parseFloat(document.getElementById("param-tolerancia").value);
  const fatorConversao = parseFloat(document.getElementById("param-conversao").value);
  const el = document.getElementById("tolerancia-em-gramas");
  if (el && !isNaN(toleranciaBruta) && !isNaN(fatorConversao) && fatorConversao !== 0) {
    el.textContent = '‚âà ' + (toleranciaBruta / fatorConversao).toFixed(3) + ' gf';
  }
}

function atualizarCapacidadeEmKg() {
  const capacidadeGramas = parseFloat(document.getElementById("param-capacidade-maxima").value);
  const el = document.getElementById("capacidade-em-kg");
  if (el && !isNaN(capacidadeGramas)) {
    el.textContent = '‚âà ' + (capacidadeGramas / 1000).toFixed(2) + ' kg';
    // Atualiza a vari√°vel global imediatamente para refletir na Zona Morta
    if (Number.isFinite(capacidadeGramas) && capacidadeGramas > 0) {
      capacidadeMaximaGramas = capacidadeGramas;
      atualizarStatusFiltros();
      console.log('[UI] capacidadeMaximaGramas atualizada via input ‚Üí', capacidadeMaximaGramas);
    }
  }
}

function atualizarErroAbsoluto() {
  const capacidadeGramas = parseFloat(document.getElementById("param-capacidade-maxima").value);
  const percentAcuracia = parseFloat(document.getElementById("param-acuracia").value);
  const el = document.getElementById("erro-absoluto");
  if (el && !isNaN(capacidadeGramas) && !isNaN(percentAcuracia)) {
    el.textContent = 'Erro: ¬±' + (capacidadeGramas * percentAcuracia).toFixed(2) + ' g';
    // Atualiza a vari√°vel global imediatamente para refletir na Zona Morta
    if (Number.isFinite(percentAcuracia) && percentAcuracia > 0) {
      percentualAcuracia = percentAcuracia;
      atualizarStatusFiltros();
      console.log('[UI] percentualAcuracia atualizado via input ‚Üí', percentualAcuracia);
    }
  }
}

// --- Fun√ß√µes de Filtros e An√°lise de Ru√≠do ---

/**
 * PIPELINE DE FILTROS para normalizar leituras de for√ßa
 * Aplicados na seguinte ordem (critial para resultados corretos):
 * 1. Zona Morta - Neutraliza ru√≠do dentro da margem de erro da c√©lula
 * 2. Arredondamento Inteligente - Ajusta casas decimais baseado na precis√£o
 * 
 * N√ÉO √© aplicado aqui: Anti-Noising (aplicado DEPOIS na UI)
 */
function aplicarFiltrosGramas(valorGramas) {
  let valor = valorGramas;
  if (filtroZonaMortaAtivo) valor = aplicarZonaMorta(valor);
  if (arredondamentoInteligenteAtivo) valor = aplicarArredondamentoInteligente(valor);
  return valor;
}

function aplicarZonaMorta(valorGramas) {
  // Calcula a margem de erro absoluta da c√©lula de carga
  // F√≥rmula: erro = capacidade m√°xima √ó percentual de acur√°cia
  // Exemplo: 20000g √ó 0.017% = 3.4g
  const erroAbsoluto = capacidadeMaximaGramas * percentualAcuracia;
  
  // Se o valor est√° dentro da margem de erro (+/-), neutraliza para zero
  // Evita que oscila√ß√µes de ru√≠do apare√ßam como leituras reais
  const resultado = Math.abs(valorGramas) <= erroAbsoluto ? 0 : valorGramas;
  
  // Log apenas quando houver mudan√ßa (evita spam no console)
  if (resultado === 0 && valorGramas !== 0) {
    console.log('[ZonaMorta] Valor', valorGramas.toFixed(3), 'g ‚Üí 0 (limite:', erroAbsoluto.toFixed(2), 'g)');
  }
  
  return resultado;
}

function aplicarArredondamentoInteligente(valorGramas) {
  const erroAbsoluto = capacidadeMaximaGramas * percentualAcuracia;
  let casasDecimais = (erroAbsoluto >= 1) ? 1 : (erroAbsoluto >= 0.1) ? 2 : 3;
  return parseFloat(valorGramas.toFixed(casasDecimais));
}

function atualizarStatusFiltros() {
  const erroAbsoluto = capacidadeMaximaGramas * percentualAcuracia;
  casasDecimais = (erroAbsoluto >= 1) ? 1 : (erroAbsoluto >= 0.1) ? 2 : 3;

  console.log('[atualizarStatusFiltros] capacidadeMaximaGramas:', capacidadeMaximaGramas);
  console.log('[atualizarStatusFiltros] percentualAcuracia:', percentualAcuracia);
  console.log('[atualizarStatusFiltros] Erro Absoluto (Zona Morta):', erroAbsoluto.toFixed(2), 'g');

  const infoZonaMorta = document.getElementById('info-zona-morta');
  if (infoZonaMorta) {
    infoZonaMorta.textContent = filtroZonaMortaAtivo ? '‚úì Zona Morta (¬±' + erroAbsoluto.toFixed(2) + 'g)' : '‚úó Zona Morta';
    infoZonaMorta.style.color = filtroZonaMortaAtivo ? '#27ae60' : '#95a5a6';
  }

  const infoArredondamento = document.getElementById('info-arredondamento');
  if (infoArredondamento) {
    infoArredondamento.textContent = arredondamentoInteligenteAtivo ? '‚úì Arredondamento (' + casasDecimais + ' casas)' : '‚úó Arredondamento';
    infoArredondamento.style.color = arredondamentoInteligenteAtivo ? '#27ae60' : '#95a5a6';
  }
}

// Garante que os bot√µes reflitam o estado atual dos filtros
function syncFilterButtonsUI() {
  const btnZona = document.getElementById('btn-zona-morta');
  if (btnZona) {
    btnZona.textContent = 'Zona Morta: ' + (filtroZonaMortaAtivo ? 'ON' : 'OFF');
    btnZona.style.background = filtroZonaMortaAtivo ? '#27ae60' : '#95a5a6';
  }
  const btnArr = document.getElementById('btn-arredondamento');
  if (btnArr) {
    btnArr.textContent = 'Arredondar: ' + (arredondamentoInteligenteAtivo ? 'ON' : 'OFF');
    btnArr.style.background = arredondamentoInteligenteAtivo ? '#27ae60' : '#95a5a6';
  }
}

function toggleFiltroZonaMorta() {
  filtroZonaMortaAtivo = !filtroZonaMortaAtivo;
  const btn = document.getElementById('btn-zona-morta');
  btn.textContent = 'Zona Morta: ' + (filtroZonaMortaAtivo ? 'ON' : 'OFF');
  btn.style.background = filtroZonaMortaAtivo ? '#27ae60' : '#95a5a6';
  atualizarStatusFiltros();
  salvarConfiguracoesGrafico(); // Salvar automaticamente
}

function toggleArredondamentoInteligente() {
  arredondamentoInteligenteAtivo = !arredondamentoInteligenteAtivo;
  const btn = document.getElementById('btn-arredondamento');
  btn.textContent = 'Arredondar: ' + (arredondamentoInteligenteAtivo ? 'ON' : 'OFF');
  btn.style.background = arredondamentoInteligenteAtivo ? '#27ae60' : '#95a5a6';
  atualizarStatusFiltros();
  salvarConfiguracoesGrafico(); // Salvar automaticamente
}

// --- Fun√ß√£o de Debug para Zona Morta ---
function debugZonaMorta() {
  const erroAbsoluto = capacidadeMaximaGramas * percentualAcuracia;
  
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üîç DEBUG ZONA MORTA');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üìä Par√¢metros Globais:');
  console.log('  capacidadeMaximaGramas:', capacidadeMaximaGramas);
  console.log('  percentualAcuracia:', percentualAcuracia);
  console.log('  Erro Absoluto (Zona Morta):', erroAbsoluto.toFixed(2), 'g');
  console.log('  Filtro Ativo:', filtroZonaMortaAtivo);
  console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
  console.log('üß™ Testes de Valores:');
  
  const testValues = [0, 0.1, 0.5, 1, 2, 5, 10, 50, 100];
  testValues.forEach(val => {
    const resultado = aplicarZonaMorta(val);
    const status = resultado === 0 ? '‚Üí ZERADO' : '‚Üí MANTIDO';
    console.log(`  ${val.toFixed(1)}g ${status} (resultado: ${resultado.toFixed(3)}g)`);
  });
  
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  showNotification('info', `Debug Zona Morta conclu√≠do! Limite atual: ¬±${erroAbsoluto.toFixed(2)}g. Veja o console.`, 5000);
}

function toggleAntiNoising() {
  antiNoisingAtivo = !antiNoisingAtivo;
  const btn = document.getElementById('btn-anti-noising');
  if (antiNoisingAtivo) {
    btn.textContent = 'Anti-Noising: ON';
    btn.classList.add('btn-sucesso');
  } else {
    btn.textContent = 'Anti-Noising: OFF';
    btn.classList.remove('btn-sucesso');
  }
}

function applyAntiNoising(forceValue) {
  if (currentStdDev === 0) return forceValue;
  const threshold = currentStdDev * antiNoisingMultiplier;
  return Math.abs(forceValue - noiseMean) <= threshold ? 0 : forceValue - noiseMean;
}

function calculateNoiseStatistics(forceValue) {
  noiseBuffer.push(forceValue);
  if (noiseBuffer.length > NOISE_BUFFER_SIZE) noiseBuffer.shift();
  if (noiseBuffer.length < 10) return;
  noiseMean = noiseBuffer.reduce((s, v) => s + v, 0) / noiseBuffer.length;
  const variance = noiseBuffer.reduce((s, v) => s + Math.pow(v - noiseMean, 2), 0) / noiseBuffer.length;
  currentStdDev = Math.sqrt(variance);
  updateNoiseDisplay();
}

function updateNoiseDisplay() {
  // This function is intentionally left blank as the controls are not in the main UI anymore
}

function startNoiseAnalysis() {
  isStabilityMode = true;
  noiseBuffer = [];
  showNotification('info', 'Analisando ru√≠do... Mantenha a balan√ßa VAZIA e EST√ÅVEL por 5 segundos!', 5000);
  setTimeout(() => {
    isStabilityMode = false;
    showNotification('success', '‚úÖ Ru√≠do calibrado!');
  }, 5000);
}

function resetNoiseAnalysis() {
  noiseBuffer = []; currentStdDev = 0; noiseMean = 0; isStabilityMode = false;
  showNotification('info', 'An√°lise de ru√≠do resetada');
}

function setAntiNoisingMultiplier(multiplier) {
  antiNoisingMultiplier = parseFloat(multiplier);
}

function atualizarInfoMultiplier() {
  const multiplierInput = document.getElementById('anti-noising-multiplier');
  const infoMultiplier = document.getElementById('info-multiplier');
  if (multiplierInput && infoMultiplier) {
    const valor = parseFloat(multiplierInput.value);
    infoMultiplier.textContent = `Valor atual: ${valor.toFixed(1)}x desvio padr√£o`;
  }
}

function addNoiseControlsToUI() {
  // This function is intentionally left blank as the controls are not in the main UI anymore
}

// --- Fun√ß√µes de √Åudio e Alertas ---

function inicializarAudioContext() {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  } catch (e) { console.warn('√Åudio n√£o dispon√≠vel'); }
}

function toggleAvisosAudio() {
  avisosAudioAtivados = document.getElementById('audio-avisos').checked;
  if (avisosAudioAtivados && audioContext?.state === 'suspended') audioContext.resume();
  showNotification('info', 'üîä Avisos sonoros ' + (avisosAudioAtivados ? 'ativados' : 'desativados'));
  salvarConfiguracoesGrafico(); // Salvar automaticamente
}

function tocarBeep(freq = 800, dur = 100, vol = 0.2) {
  if (!avisosAudioAtivados || !audioContext) return;
  const osc = audioContext.createOscillator();
  const gain = audioContext.createGain();
  osc.connect(gain);
  gain.connect(audioContext.destination);
  osc.frequency.value = freq;
  gain.gain.setValueAtTime(vol, audioContext.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + dur / 1000);
  osc.start();
  osc.stop(audioContext.currentTime + dur / 1000);
}

function tocarAlertaDesconexao() { tocarBeep(400, 100); setTimeout(() => tocarBeep(300, 100), 150); }
function tocarAlertaReconexao() { tocarBeep(600, 100); setTimeout(() => tocarBeep(800, 100), 120); }
function tocarAlertaEstabilizacao() { tocarBeep(500, 150); }

function verificarStatusEstabilizacao(status) {
  const problema = status?.includes('n√£o estabilizando');
  if (problema && !ultimoStatusEstabilizacao) {
    contadorFalhasEstabilizacao++;
    if (contadorFalhasEstabilizacao >= 3) document.getElementById('alerta-estabilizacao').classList.add('ativo');
  } else if (!problema) {
    contadorFalhasEstabilizacao = 0;
    document.getElementById('alerta-estabilizacao').classList.remove('ativo');
  }
  ultimoStatusEstabilizacao = !problema;
}

// --- Atalhos de Teclado ---

function setupKeyboardShortcuts() {
  document.addEventListener('keydown', (event) => {
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;
    const key = event.key.toLowerCase();
    const fullscreenModalEl = document.getElementById('fullscreen-chart-modal');

    // Handle Escape key for fullscreen exit
    if (key === 'escape' && fullscreenModalEl.classList.contains('active')) {
      event.preventDefault();
      toggleFullscreen();
      return; // Exit early to prevent other shortcuts from firing
    }

    if (event.shiftKey) {
      if (key === 't') { event.preventDefault(); tare(); }
      else if (key === 'c') { event.preventDefault(); calibrar(); }
      else if (key === 'a') { event.preventDefault(); startNoiseAnalysis(); }
      else if (key === 'd') { event.preventDefault(); debugZonaMorta(); } // NOVO: Debug Zona Morta
    } else if (!event.ctrlKey && !event.metaKey) {
      if (key === 'l') { event.preventDefault(); clearChart(); }
      else if (key === 'p') { event.preventDefault(); toggleChartPause(); }
    }
  });
}

let isDataLabelsEnabled = false;
let chartDisplayMode = 'points';
let casasDecimais = 6; // Default value
let isGridEnabled = true;

function toggleDataLabels() {
  isDataLabelsEnabled = !isDataLabelsEnabled;
  chart.updateOptions({
    dataLabels: {
      enabled: isDataLabelsEnabled,
      offsetY: -10, // Move labels slightly above the points
      style: {
        fontSize: '10px',
      },
      formatter: function (val) {
        return val.toFixed(6) + ' ' + displayUnit;
      }
    }
  });
}

function toggleChartDisplayMode() {
  const modes = ['points', 'line', 'both'];
  let currentIndex = modes.indexOf(chartDisplayMode);
  let nextIndex = (currentIndex + 1) % modes.length;
  chartDisplayMode = modes[nextIndex];

  const btn = document.getElementById('btn-toggle-display-mode');
  let btnText = '';
  let strokeWidth = 0;
  let markerSize = 0;

  switch (chartDisplayMode) {
    case 'points':
      btnText = 'Modo: Somente Pontos';
      markerSize = 4;
      strokeWidth = 0;
      break;
    case 'line':
      btnText = 'Modo: Somente Linha';
      markerSize = 0;
      strokeWidth = 2.5;
      break;
    case 'both':
      btnText = 'Modo: Linha + Pontos';
      markerSize = 4;
      strokeWidth = 2.5;
      break;
  }

  btn.textContent = btnText;
  chart.updateOptions({
    stroke: {
      width: strokeWidth
    },
    markers: {
      size: markerSize
    }
  });
  showNotification('info', 'Modo de exibi√ß√£o do gr√°fico: ' + btnText.replace('Modo: ', '') + '.');
}

function setInterpolation(curve) {
  chart.updateOptions({
    stroke: {
      curve: curve
    }
  });
}



function toggleFullscreen() {
  const chartEl = document.querySelector("#grafico");
  const fullscreenModalEl = document.getElementById('fullscreen-chart-modal');
  const fullscreenButton = document.getElementById('btn-toggle-fullscreen');
  const bodyEl = document.body;

  // Get the target btn-grupo within originalChartContainer (the one next to the chart)
  const chartSideControls = originalChartContainer.querySelector(".btn-grupo");

  if (!fullscreenModalEl.classList.contains('active')) {
    // Entering Fullscreen Modal Mode
    if (!originalChartContainer || !originalChartSessionControlsContainer || !originalChartControlsParent) {
      console.error("Original chart containers or controls parent not found!");
      return;
    }

    // Move specific buttons from originalChartControlsParent to chartSideControls
    chartSideControls.appendChild(btnToggleLabels);
    chartSideControls.appendChild(btnToggleDisplayMode);
    chartSideControls.appendChild(btnToggleGrid);
    chartSideControls.appendChild(btnSetSmoothLine);
    chartSideControls.appendChild(btnSetStraightLine);

    // Move the entire originalChartContainer (now with all relevant buttons) to the modal
    fullscreenModalEl.appendChild(originalChartContainer);

    // Hide the original session controls container as its buttons have been moved
    originalChartSessionControlsContainer.style.display = 'none';

    fullscreenModalEl.classList.add('active');
    bodyEl.classList.add('no-scroll');
    if (fullscreenButton) fullscreenButton.textContent = 'Sair da Tela Cheia';

    // Update chart options for fullscreen
    requestAnimationFrame(() => {
      chart.updateOptions({
        chart: {
          height: '100%', // Let ApexCharts manage height based on its new parent
          width: '100%'
        }
      });
      setTimeout(() => {
        chart.windowResize();
      }, 50);
    });

  } else {
    // Exiting Fullscreen Modal Mode
    const abaGrafico = document.getElementById('abaGrafico');

    // Move specific buttons back from chartSideControls to originalChartControlsParent
    originalChartControlsParent.appendChild(btnToggleLabels);
    originalChartControlsParent.appendChild(btnToggleDisplayMode);
    originalChartControlsParent.appendChild(btnToggleGrid);
    originalChartControlsParent.appendChild(btnSetSmoothLine);
    originalChartControlsParent.appendChild(btnSetStraightLine);

    // Move the originalChartContainer back to its original location
    abaGrafico.appendChild(originalChartContainer);

    // Show the original session controls container again
    originalChartSessionControlsContainer.style.display = 'flex'; // Assuming it was flex

    fullscreenModalEl.classList.remove('active');
    bodyEl.classList.remove('no-scroll');
    if (fullscreenButton) fullscreenButton.textContent = 'Tela Cheia';

    // Revert chart options to original
    requestAnimationFrame(() => {
      chart.updateOptions({
        chart: {
          height: 450, // Original height from initializeApexChart
          width: '100%'
        }
      });
      setTimeout(() => {
        chart.windowResize();
      }, 50);
    });
  }
}

function toggleGrid() {
  isGridEnabled = !isGridEnabled;
  chart.updateOptions({
    grid: {
      show: isGridEnabled
    }
  });
  const btn = document.getElementById('btn-toggle-grid');
  btn.textContent = 'Grade: ' + (isGridEnabled ? 'ON' : 'OFF');
  showNotification('info', 'Grade do gr√°fico: ' + (isGridEnabled ? 'ON' : 'OFF') + '.');
}

function setYAxisRange(mode) {
  if (mode === 'auto') {
    chart.updateOptions({
      yaxis: {
        min: undefined,
        max: undefined
      }
    });
  } else if (mode === 'fixed') {
    // A capacidadeMaximaGramas √© atualizada pela fun√ß√£o updateConfigForm
    if (!capacidadeMaximaGramas || capacidadeMaximaGramas <= 0) {
      showNotification('error', 'Capacidade m√°xima da c√©lula n√£o definida. Verifique os par√¢metros.');
      return;
    }

    let maxRange;
    const gravity = 9.80665;
    const maxForceInN = (capacidadeMaximaGramas / 1000) * gravity;
    maxRange = convertForce(maxForceInN, displayUnit);

    chart.updateOptions({
      yaxis: {
        min: 0,
        max: maxRange
      }
    });
  }
}

// --- Fun√ß√µes de Sess√£o (Local Storage e DB) ---

// Util: interpreta timestamp vindo do DB como UTC e formata para dd/mm/yyyy HH:MM:SS.mmm (UTC)
function parseDbTimestampToUTC(ts) {
  if (!ts) return null;
  let s = typeof ts === 'string' ? ts : String(ts);
  // Normaliza: 'YYYY-MM-DD HH:MM:SS(.ffffff)' -> 'YYYY-MM-DDTHH:MM:SS(.mmm)Z'
  s = s.replace(' ', 'T');
  // Mant√©m no m√°ximo 3 casas decimais (milissegundos)
  s = s.replace(/\.(\d{3})\d+$/, '.$1');
  if (!/Z$/i.test(s)) s += 'Z';
  return new Date(s);
}

function formatUtcDdMm(date) {
  if (!date) return '';
  const dd = String(date.getUTCDate()).padStart(2, '0');
  const mm = String(date.getUTCMonth() + 1).padStart(2, '0');
  const yyyy = date.getUTCFullYear();
  const HH = String(date.getUTCHours()).padStart(2, '0');
  const MM = String(date.getUTCMinutes()).padStart(2, '0');
  const SS = String(date.getUTCSeconds()).padStart(2, '0');
  const mmm = String(date.getUTCMilliseconds()).padStart(3, '0');
  return `${dd}/${mm}/${yyyy} ${HH}:${MM}:${SS}.${mmm}`;
}

async function fetchDbSessions() {
  try {
    const response = await apiFetch('/api/sessoes');
    if (!response.ok) {
      throw new Error('Erro na rede: ' + response.statusText);
    }
    return await response.json();
  } catch (error) {
    console.error('Erro ao buscar sess√µes do DB:', error);
    showNotification('error', 'N√£o foi poss√≠vel buscar as sess√µes do banco de dados.');
    return [];
  }
}

async function loadAndDisplayAllSessions() {
  const listaGravacoesDiv = document.getElementById('lista-gravacoes');
  listaGravacoesDiv.innerHTML = '<p>Carregando sess√µes...</p>';

  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  const dbSessions = await fetchDbSessions();

  const allSessionsMap = new Map();

  localSessions.forEach(session => {
    allSessionsMap.set(session.id, { ...session, source: 'local', inLocal: true });
  });

  dbSessions.forEach(dbSession => {
    const existingSession = allSessionsMap.get(dbSession.id);
    if (existingSession) {
      // Detectar conflito: comparar data_modificacao
      const localModified = existingSession.data_modificacao ? new Date(existingSession.data_modificacao) : new Date(0);
      const dbModified = dbSession.data_modificacao ? new Date(dbSession.data_modificacao) : new Date(0);

      const hasConflict = Math.abs(localModified - dbModified) > 1000; // Diferen√ßa maior que 1 segundo

      allSessionsMap.set(dbSession.id, {
        ...existingSession,
        ...dbSession,
        source: 'both',
        inDb: true,
        hasConflict: hasConflict,
        localModified: existingSession.data_modificacao,
        dbModified: dbSession.data_modificacao
      });
    } else {
      allSessionsMap.set(dbSession.id, { ...dbSession, source: 'db', inDb: true });
    }
  });

  const combinedSessions = Array.from(allSessionsMap.values()).sort((a, b) => b.id - a.id);

  if (combinedSessions.length === 0) {
    listaGravacoesDiv.innerHTML = '<p>Nenhuma grava√ß√£o encontrada (local ou no banco de dados).</p>';
    return;
  }

  // Para sess√µes do DB sem dadosTabela, buscar as leituras
  for (const session of combinedSessions) {
    if (session.inDb && (!session.dadosTabela || session.dadosTabela.length === 0)) {
      try {
        const readingsResp = await apiFetch(`/api/sessoes/${session.id}/leituras`);
        if (readingsResp.ok) {
          const dbReadings = await readingsResp.json();
          session.dadosTabela = dbReadings.map(r => ({
            timestamp: formatUtcDdMm(parseDbTimestampToUTC(r.timestamp)),
            tempo_esp: r.tempo,
            newtons: r.forca,
            grama_forca: (r.forca / 9.80665 * 1000),
            quilo_forca: (r.forca / 9.80665)
          }));
        }
      } catch (e) {
        console.warn(`N√£o foi poss√≠vel carregar leituras da sess√£o ${session.id}:`, e);
      }
    }
  }

  listaGravacoesDiv.innerHTML = combinedSessions.map(session => {
    const sourceIcons = `${session.inLocal ? '<span title="Salvo Localmente" style="margin-right: 5px;">üíæ</span>' : ''}${session.inDb ? '<span title="Salvo no Banco de Dados" style="margin-right: 5px;">‚òÅÔ∏è</span>' : ''}`;
  const baseStart = session.data_inicio || session.timestamp;
  const dataInicio = baseStart ? parseDbTimestampToUTC(baseStart).toLocaleString('pt-BR') : 'N/D';

    let impulsoTotal = 'N/A';
    let motorClass = 'N/A';
    let classColor = '#95a5a6'; // Default gray color

    if (session.dadosTabela && session.dadosTabela.length > 0) {
      const dados = processarDadosSimples(session.dadosTabela);
      const impulsoData = calcularAreaSobCurva(dados.tempos, dados.newtons, false);
      const metricasPropulsao = calcularMetricasPropulsao(impulsoData);
      impulsoTotal = impulsoData.impulsoTotal.toFixed(2);
      motorClass = metricasPropulsao.classificacaoMotor.classe;
      classColor = metricasPropulsao.classificacaoMotor.cor; // Get color from classification
    }

    // Metadados do motor
    const meta = session.metadadosMotor || {};
    const metadadosDisplay = meta.name ? `
      <p style="font-size: 0.75rem; color: var(--cor-texto-secundario); margin-top: 5px;">
        üöÄ Motor: ${meta.name || 'N/D'} ‚Ä¢ ‚åÄ${meta.diameter || 'N/D'}mm ‚Ä¢ L${meta.length || 'N/D'}mm ‚Ä¢
        Prop: ${meta.propweight || 'N/D'}kg ‚Ä¢ Total: ${meta.totalweight || 'N/D'}kg ‚Ä¢ ${meta.manufacturer || 'N/D'}
      </p>
    ` : '';

    // Indicador de conflito
    const conflictIndicator = session.hasConflict ? `
      <span style="background: #e74c3c; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-left: 8px;">
        ‚ö†Ô∏è CONFLITO
      </span>
    ` : '';

    return `
      <div class="card-gravacao" style="display: flex; justify-content: space-between; align-items: center; background: var(--cor-fundo-card); padding: 15px; border-radius: 8px; box-shadow: rgba(0, 0, 0, 0.1) 0px 2px 10px; margin-bottom: 10px; border-left: 5px solid ${classColor};" id="session-${session.id}">
        <div style="flex: 1;">
            <p style="font-weight: 600; margin-bottom: 5px;">${sourceIcons}${session.nome} <span style="font-size: 0.75rem; background: ${classColor}; color: white; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">CLASSE ${motorClass}</span>${conflictIndicator}</p>
            <p style="font-size: 0.875rem; color: var(--cor-texto-secundario);">
                ${dataInicio} ‚Ä¢ Impulso Total: ${impulsoTotal} N‚ãÖs
            </p>
            ${metadadosDisplay}
        </div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            ${session.hasConflict
        ? `<button onclick="resolverConflito(${session.id})" title="Resolver Conflito de Sincroniza√ß√£o" class="btn btn-aviso">‚ö†Ô∏è Resolver Conflito</button>`
        : ''}
            <button onclick="visualizarSessao(${session.id}, '${session.source}')" title="Carregar para An√°lise/Gr√°fico" class="btn btn-info">Ô∏è Ver</button>
            <button onclick="editarMetadadosMotor(${session.id})" title="Editar Metadados do Motor" class="btn btn-secundario">‚öôÔ∏è Metadados</button>
            <button onclick="exportarImagemSessao(${session.id}, '${session.source}')" title="Exportar Gr√°fico em PNG" class="btn btn-primario">Ô∏è PNG</button>
            <button onclick="gerarRelatorioPdf(${session.id}, '${session.source}')" title="Exportar Relat√≥rio PDF" class="btn btn-secundario"> PDF</button>
            <button onclick="exportarJSON(${session.id}, '${session.source}')" title="Exportar Dados em JSON" class="btn btn-sucesso"> JSON</button>
            <button onclick="exportarCSV(${session.id}, '${session.source}')" title="Exportar Dados em CSV" class="btn btn-sucesso"> CSV</button>
            <button onclick="exportarEng(${session.id}, '${session.source}')" title="Exportar Curva de Empuxo para OpenRocket/RASAero" class="btn btn-aviso"> ENG</button>
            ${session.inLocal && !session.inDb
        ? `<button class="btn btn-info btn-small"
                ${!isMysqlConnected ? 'disabled title="MySQL desconectado"' : 'title="Salvar do LocalStorage para o Banco de Dados"'}
                onclick="salvarNoDB(${session.id})">
                üíæ ‚ûú ‚òÅÔ∏è Salvar no BD
             </button>
             <button class="btn btn-perigo btn-small" title="Excluir do LocalStorage" onclick="deleteLocalSession(${session.id})">üóëÔ∏è Excluir do Local</button>`
        : ''}
            ${session.inDb && !session.inLocal
        ? `<button class="btn btn-perigo btn-small" title="Excluir do Banco de Dados" onclick="deleteDbSession(${session.id})">üóëÔ∏è Excluir do BD</button>
             <button class="btn btn-info btn-small"
                title="Salvar do Banco de Dados para o LocalStorage"
                onclick="salvarNoLocalStorage(${session.id})">
                ‚òÅÔ∏è ‚ûú üíæ Salvar Local
             </button>`
        : ''}
            ${session.inDb && session.inLocal
        ? `<button class="btn btn-perigo btn-small" title="Excluir do Banco de Dados" onclick="deleteDbSession(${session.id})">üóëÔ∏è Excluir do BD</button>
             <button class="btn btn-perigo btn-small" title="Excluir do LocalStorage" onclick="deleteLocalSession(${session.id})">üóëÔ∏è Excluir do Local</button>`
        : ''}
        </div>
      </div>
    `;

  }).join('');
}

/** Ordem dos bot√µes  para salvar 
S√≥ no LocalStorage:       üíæ ‚ûú ‚òÅÔ∏è Salvar no BD e üóëÔ∏è Excluir do Local
S√≥ no BD:                üóëÔ∏è Excluir do BD e  ‚òÅÔ∏è ‚ûú üíæ Salvar Local
Em ambos:                üóëÔ∏è Excluir do BD e üóëÔ∏è Excluir do Local

 */

function salvarNoLocalStorage(sessionId) {
  saveDbSessionToLocal(sessionId);
}

function salvarNoDB(sessionId) {
  saveLocalSessionToDb(sessionId);
}

async function editarMetadadosMotor(sessionId) {
  // Busca a sess√£o (local ou DB)
  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  let session = localSessions.find(s => s.id === sessionId);

  // Se n√£o est√° localmente, tenta buscar do DB
  if (!session) {
    try {
      const resp = await apiFetch(`/api/sessoes/${sessionId}`);
      if (resp.ok) {
        session = await resp.json();
      }
    } catch (e) {
      console.error('Erro ao buscar sess√£o do DB:', e);
    }
  }

  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para editar metadados.');
    return;
  }

  const meta = session.metadadosMotor || {};

  // Cria um modal para edi√ß√£o
  const modalHtml = `
    <div id="modal-metadados" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000; overflow-y: auto;">
      <div style="background: var(--cor-fundo); padding: 30px; border-radius: 12px; max-width: 700px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3); margin: 20px;">
        <h2 style="margin-top: 0; color: var(--cor-titulo);">‚öôÔ∏è Metadados do Motor - ${session.nome}</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Nome do Motor</label>
            <input type="text" id="meta-name" value="${meta.name || ''}" placeholder="Ex: NFB_20" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Fabricante</label>
            <input type="text" id="meta-manufacturer" value="${meta.manufacturer || 'GFIG-IFC'}" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Di√¢metro (mm)</label>
            <input type="number" id="meta-diameter" value="${meta.diameter || 45}" step="0.1" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Comprimento (mm)</label>
            <input type="number" id="meta-length" value="${meta.length || 200}" step="1" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Delay (s)</label>
            <input type="number" id="meta-delay" value="${meta.delay || 0}" step="0.1" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div>
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Peso Propelente (kg)</label>
            <input type="number" id="meta-propweight" value="${meta.propweight || 0.1}" step="0.001" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div style="grid-column: 1 / -1;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">Peso Total (kg)</label>
            <input type="number" id="meta-totalweight" value="${meta.totalweight || 0.25}" step="0.001" style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px;">
          </div>
          <div style="grid-column: 1 / -1;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">üìù Descri√ß√£o</label>
            <textarea id="meta-description" placeholder="Descri√ß√£o detalhada do motor..." style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px; min-height: 80px; resize: vertical; font-family: inherit;">${meta.description || ''}</textarea>
          </div>
          <div style="grid-column: 1 / -1;">
            <label style="display: block; margin-bottom: 5px; font-weight: 600;">üí¨ Observa√ß√µes</label>
            <textarea id="meta-observations" placeholder="Observa√ß√µes adicionais sobre o teste..." style="width: 100%; padding: 8px; border: 1px solid var(--cor-borda); border-radius: 4px; min-height: 80px; resize: vertical; font-family: inherit;">${meta.observations || ''}</textarea>
          </div>
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button onclick="fecharModalMetadados()" class="btn btn-secundario">Cancelar</button>
          <button onclick="salvarMetadadosMotor(${sessionId})" class="btn btn-sucesso">üíæ Salvar Metadados</button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function fecharModalMetadados() {
  const modal = document.getElementById('modal-metadados');
  if (modal) modal.remove();
}

async function salvarMetadadosMotor(sessionId) {
  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  const sessionIndex = localSessions.findIndex(s => s.id === sessionId);

  // Captura os valores do formul√°rio
  const metadadosMotor = {
    name: document.getElementById('meta-name').value.trim(),
    manufacturer: document.getElementById('meta-manufacturer').value.trim(),
    diameter: parseFloat(document.getElementById('meta-diameter').value) || 45,
    length: parseFloat(document.getElementById('meta-length').value) || 200,
    delay: parseFloat(document.getElementById('meta-delay').value) || 0,
    propweight: parseFloat(document.getElementById('meta-propweight').value) || 0.1,
    totalweight: parseFloat(document.getElementById('meta-totalweight').value) || 0.25,
    description: document.getElementById('meta-description').value.trim(),
    observations: document.getElementById('meta-observations').value.trim()
  };

  let sessionToUpdate = null;
  let isInLocal = sessionIndex !== -1;

  // Se existe localmente, atualiza no local storage
  if (isInLocal) {
    localSessions[sessionIndex].metadadosMotor = metadadosMotor;
    localSessions[sessionIndex].data_modificacao = new Date().toISOString();
    sessionToUpdate = localSessions[sessionIndex];

    try {
      localStorage.setItem('balancaGravacoes', JSON.stringify(localSessions));
      showNotification('success', 'Metadados do motor salvos localmente!');
    } catch (e) {
      showNotification('error', 'Erro ao salvar metadados localmente: ' + e.message);
      fecharModalMetadados();
      return;
    }
  }

  // Se n√£o est√° localmente, busca do DB para ter os dados completos
  if (!sessionToUpdate) {
    try {
      const resp = await apiFetch(`/api/sessoes/${sessionId}`);
      if (resp.ok) {
        sessionToUpdate = await resp.json();
        sessionToUpdate.metadadosMotor = metadadosMotor;

        // Normaliza campos do DB para o formato esperado pelo worker
        if (sessionToUpdate.data_inicio && !sessionToUpdate.timestamp) {
          sessionToUpdate.timestamp = sessionToUpdate.data_inicio;
        }
        if (!sessionToUpdate.nome) {
          sessionToUpdate.nome = 'Sess√£o ' + sessionId;
        }
      }
    } catch (e) {
      console.error('Erro ao buscar sess√£o do DB:', e);
    }
  } else {
    // Atualiza os metadados na sess√£o local se j√° temos ela
    sessionToUpdate.metadadosMotor = metadadosMotor;
  }

  // Tenta salvar no DB se MySQL est√° conectado e temos a sess√£o
  if (isMysqlConnected && sessionToUpdate) {
    // Busca as leituras se n√£o estiverem presentes
    if (!sessionToUpdate.dadosTabela || sessionToUpdate.dadosTabela.length === 0) {
      try {
        const readingsResp = await apiFetch(`/api/sessoes/${sessionId}/leituras`);
        if (readingsResp.ok) {
          const dbReadings = await readingsResp.json();
          sessionToUpdate.dadosTabela = dbReadings.map(r => ({
            timestamp: formatUtcDdMm(parseDbTimestampToUTC(r.timestamp)),
            tempo_esp: r.tempo,
            newtons: r.forca,
            grama_forca: (r.forca / 9.80665 * 1000),
            quilo_forca: (r.forca / 9.80665)
          }));
        }
      } catch (e) {
        console.warn('N√£o foi poss√≠vel carregar leituras:', e);
      }
    }

    console.log('Enviando para o banco:', sessionToUpdate); // Debug
    sendCommandToWorker('save_session_to_mysql', sessionToUpdate);
    showNotification('info', 'Atualizando metadados no banco de dados...');
  } else if (!isMysqlConnected) {
    showNotification('warning', 'MySQL desconectado. Metadados salvos apenas localmente.');
  }

  fecharModalMetadados();

  // Recarrega a lista para mostrar os novos metadados
  setTimeout(() => loadAndDisplayAllSessions(), 500);
}


async function exportarPNG(sessionId, source) {
  // NOVA VERS√ÉO: Usa o sistema avan√ßado de exporta√ß√£o PNG com configura√ß√µes
  showNotification('info', 'Gerando relat√≥rio PNG com an√°lise de propuls√£o...');

  const session = await getSessionDataForExport(sessionId, source);
  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para exportar PNG.');
    return;
  }

  // Chama a fun√ß√£o avan√ßada de exporta√ß√£o PNG (de script_grafico_sessao.js)
  if (typeof exportarImagemSessao === 'function') {
    exportarImagemSessao(session.id);
  } else {
    // Fallback para vers√£o antiga caso a fun√ß√£o nova n√£o esteja carregada
    console.warn('[PNG] Fun√ß√£o exportarImagemSessao n√£o encontrada, usando m√©todo legado');

    const chartData = session.dadosTabela.map(d => [d.tempo_esp, d.newtons]);

    const tempDiv = document.createElement('div');
    tempDiv.style.position = 'absolute';
    tempDiv.style.left = '-9999px';
    tempDiv.style.width = '800px';
    tempDiv.style.height = '600px';
    document.body.appendChild(tempDiv);

    const tempChartOptions = {
      series: [{ name: 'For√ßa', data: chartData }],
      chart: { type: 'line', height: '100%', width: '100%', background: '#fff' },
      title: { text: 'Gr√°fico da Sess√£o: ' + session.nome, align: 'center' },
      xaxis: { title: { text: 'Tempo (s)' } },
      yaxis: { title: { text: 'For√ßa (N)' } }
    };

    const tempChart = new ApexCharts(tempDiv, tempChartOptions);

    tempChart.render().then(() => {
      tempChart.dataURI().then(({ imgURI }) => {
        const a = document.createElement('a');
        a.href = imgURI;
        a.download = 'grafico_' + session.nome.replace(/[^a-zA-Z0-9_]/g, '_') + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        tempChart.destroy();
        document.body.removeChild(tempDiv);
        showNotification('success', 'Gr√°fico exportado como PNG!');
      });
    });
  }
}

async function exportarJSON(sessionId, source) {
  const session = await getSessionDataForExport(sessionId, source);
  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para exportar JSON.');
    return;
  }

  const jsonContent = JSON.stringify(session, null, 2);
  const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = session.nome.replace(/[^a-zA-Z0-9_]/g, '_') + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showNotification('success', 'Arquivo JSON para "' + session.nome + '" gerado!');
}


async function getSessionDataForExport(sessionId, source) {
  let sessionData = null;
  if (source === 'local' || source === 'both') {
    const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
    sessionData = localSessions.find(s => s.id === sessionId);
  }

  if (!sessionData && (source === 'db' || source === 'both')) { // Try DB if local not found or explicitly DB
    try {
      const dbSessionResponse = await apiFetch('/api/sessoes');
      if (!dbSessionResponse.ok) throw new Error('Falha ao carregar detalhes da sess√£o do DB para exporta√ß√£o.');
      const allDbSessions = await dbSessionResponse.json();
      const dbSession = allDbSessions.find(s => s.id === sessionId);

      if (dbSession) {
        const readingsResponse = await apiFetch('/api/sessoes/' + sessionId + '/leituras');
        if (!readingsResponse.ok) throw new Error('Falha ao carregar leituras do DB para exporta√ß√£o.');
        const dbReadings = await readingsResponse.json();

        sessionData = {
          id: dbSession.id,
          nome: dbSession.nome,
          timestamp: dbSession.data_inicio,
          data_modificacao: dbSession.data_modificacao || new Date().toISOString(),
          dadosTabela: dbReadings.map(r => ({
            timestamp: formatUtcDdMm(parseDbTimestampToUTC(r.timestamp)),
            tempo_esp: r.tempo,
            newtons: r.forca,
            grama_forca: (r.forca / 9.80665 * 1000),
            quilo_forca: (r.forca / 9.80665)
          })),
          metadadosMotor: dbSession.metadadosMotor || {},
          savedToMysql: true
        };
      }
    } catch (error) {
      console.error('Erro ao buscar sess√£o do DB para exporta√ß√£o:', error);
      showNotification('error', 'Erro ao carregar sess√£o ' + sessionId + ' do DB para exporta√ß√£o.');
      return null;
    }
  }
  return sessionData;
}
// Visualiza uma sess√£o salva (gr√°fico + tabela) garantindo eixo X num√©rico e ordenado
// Localizado em script.js

// ... (resto do c√≥digo)

// Visualiza uma sess√£o salva (gr√°fico + tabela) garantindo eixo X num√©rico e ordenado
async function visualizarSessao(sessionId) {
  try {
    // 1) Obter sess√£o (LocalStorage ‚Üí API)
    const gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes') || '[]');
    let sessao = gravacoes.find(g => String(g.id) === String(sessionId));

    // Se n√£o for encontrada localmente, tenta buscar o registro no DB
    if (!sessao) {
      try {
        const resp = await apiFetch(`/api/sessoes/${sessionId}`, { cache: 'no-store' });
        if (resp.ok) sessao = await resp.json();
      } catch (e) {
        console.error("Erro ao buscar metadados da sess√£o no DB:", e);
      }
    }

    // Se o registro da sess√£o foi encontrado (local ou DB), mas os dadosTabela est√£o ausentes ou vazios,
    // E a sess√£o *pode* estar no DB (checar se tem os campos do DB, ex: data_inicio), buscamos as leituras no DB.
    if (sessao && (!Array.isArray(sessao.dadosTabela) || sessao.dadosTabela.length === 0)) {
      // Tentativa de buscar leituras do DB, caso o registro da sess√£o tenha vindo da API.
      // Assumimos que a sess√£o √© do DB se ela veio da API e n√£o tem dadosTabela.
      try {
        const readingsResp = await apiFetch(`/api/sessoes/${sessionId}/leituras`, { cache: 'no-store' });
        if (readingsResp.ok) {
          const dbReadings = await readingsResp.json();

          // Anexa os dados lidos do DB ao objeto 'sessao'
          sessao.dadosTabela = dbReadings.map(r => ({
            timestamp: new Date(r.timestamp).toLocaleString('pt-BR', { hour12: false }).replace(', ', ' '),
            tempo_esp: r.tempo,
            newtons: r.forca,
            grama_forca: (r.forca / 9.80665 * 1000).toFixed(3),
            quilo_forca: (r.forca / 9.80665).toFixed(6)
          }));
        }
      } catch (e) {
        console.error("Erro ao buscar leituras da sess√£o no DB:", e);
        // Continua, mas com um alerta
      }
    }


    if (!sessao || !Array.isArray(sessao.dadosTabela) || sessao.dadosTabela.length === 0) {
      showNotification('error', 'Sess√£o n√£o encontrada ou sem dados.');
      return;
    }

    // 2) Normalizar ‚Üí [tempo: number, newtons: number], filtrar NaN e ORDENAR por tempo
    const parsed = sessao.dadosTabela
      .map(l => [Number(l.tempo_esp), Number(l.newtons)])
      .filter(([t, f]) => Number.isFinite(t) && Number.isFinite(f))
      .sort((a, b) => a[0] - b[0]);

    if (parsed.length < 2) {
      showNotification('error', 'Dados insuficientes para plotagem.');
      return;
    }

    // 3) Atualizar buffers internos e estat√≠sticas
    rawDataN = parsed.map(([t, f]) => [t, f]); // mant√©m base em Newtons
    maxForceInN = Math.max(...parsed.map(p => p[1]));
    minForceInN = Math.min(...parsed.map(p => p[1]));

    // 4) Atualizar gr√°fico (convertendo para a unidade atual de exibi√ß√£o)
    const displayData = parsed.map(([t, f]) => [t, convertForce(f, displayUnit)]);
    chart.updateSeries([{ data: displayData }]);

    // 5) Atualizar textos de m√©tricas no header, se existirem
    const forceNow = parsed[parsed.length - 1][1];
    const displayForceNow = convertForce(forceNow, displayUnit);
    const maxDisplayForce = convertForce(maxForceInN, displayUnit);
    const minDisplayForce = convertForce(minForceInN, displayUnit);

    const elAtual = document.getElementById('forca-atual');
    const elEms = document.getElementById('forca-ems');
    const elMax = document.getElementById('forca-maxima');
    const elMin = document.getElementById('forca-minima');

    if (elAtual) elAtual.textContent = displayForceNow.toFixed(3);
    if (elEms) elEms.textContent = displayForceNow.toFixed(3); // n√£o recomputa EMA aqui
    if (elMax) elMax.textContent = maxDisplayForce.toFixed(3);
    if (elMin) elMin.textContent = `m√≠n: ${minDisplayForce.toFixed(3)}`;

    // 6) Repopular a tabela
    const tbody = document.querySelector('#tabela tbody');
    if (tbody) {
      tbody.innerHTML = '';
      // Evita travar a UI em sess√µes muito grandes ‚Äî renderiza em blocos
      const renderChunk = (startIdx, chunkSize = 1000) => {
        const end = Math.min(startIdx + chunkSize, parsed.length);
        const frag = document.createDocumentFragment();

        for (let i = startIdx; i < end; i++) {
          const [t, N] = parsed[i];
          const gf = (N / 9.80665) * 1000;
          const kgf = (N / 9.80665);

          const tr = document.createElement('tr');
          const ts = (sessao.dadosTabela[i] && sessao.dadosTabela[i].timestamp) || '';

          const tdTs = document.createElement('td'); tdTs.textContent = ts;
          const tdT = document.createElement('td'); tdT.textContent = t.toFixed(3);
          const tdN = document.createElement('td'); tdN.textContent = N.toFixed(6);
          const tdGf = document.createElement('td'); tdGf.textContent = gf.toFixed(3);
          const tdKgf = document.createElement('td'); tdKgf.textContent = kgf.toFixed(6);

          tr.appendChild(tdTs);
          tr.appendChild(tdT);
          tr.appendChild(tdN);
          tr.appendChild(tdGf);
          tr.appendChild(tdKgf);
          frag.appendChild(tr);
        }

        tbody.appendChild(frag);

        if (end < parsed.length) {
          // Pr√≥ximo bloco na pr√≥xima itera√ß√£o do event loop
          setTimeout(() => renderChunk(end, chunkSize), 0);
        }
      };

      renderChunk(0);
    }

    // 7) Ajustes visuais/UX
    // Garantir que a aba do gr√°fico esteja ativa para o usu√°rio ver o resultado
    const btnAbaGrafico = document.getElementById('padrao');
    if (btnAbaGrafico && typeof abrirAba === 'function') {
      abrirAba(btnAbaGrafico, 'abaGrafico');
    }

    // Atualiza range do eixo Y para "auto" por padr√£o ao visualizar sess√£o
    if (typeof setYAxisRange === 'function') {
      setYAxisRange('auto');
    }

    showNotification('success', `Sess√£o "${sessao.nome || sessionId}" carregada.`);

  } catch (err) {
    console.error('Erro em visualizarSessao:', err);
    showNotification('error', 'Falha ao carregar a sess√£o: ' + (err && err.message ? err.message : 'erro desconhecido'));
  }
  //pausa  
  toggleChartPause(true);
}

async function exportarEng(sessionId, source) {
  const session = await getSessionDataForExport(sessionId, source); // Try both sources
  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para exporta√ß√£o .ENG.');
    return;
  }
  
  // Extrai metadados do motor
  const metadados = session.metadadosMotor || {};
  const nomeArquivo = (metadados.name || session.nome.replace(/[^a-zA-Z0-9_]/g, '_')) + '.eng';
  
  // Constr√≥i cabe√ßalho no formato RASP/OpenRocket
  // Coment√°rio com especifica√ß√£o dos campos
  let engContent = ';name\tdiameter\tlength\tdelay\tpropweight\ttotalweight\tmanufacturer\n';
  
  // Linha de metadados do motor (em mm, s, kg)
  engContent += (metadados.name || 'Motor').trim() + '\t';
  engContent += (metadados.diameter || 45).toFixed(1) + '\t';      // mm
  engContent += (metadados.length || 200).toFixed(1) + '\t';       // mm
  engContent += (metadados.delay || 0).toFixed(1) + '\t';          // s
  engContent += (metadados.propweight || 0.1).toFixed(5) + '\t';   // kg
  engContent += (metadados.totalweight || 0.25).toFixed(5) + '\t'; // kg
  engContent += (metadados.manufacturer || 'GFIG').trim() + '\n';
  
  // Coment√°rios informativos
  engContent += ';\n';
  engContent += '; Arquivo gerado pelo sistema GFIG\n';
  engContent += '; Data: ' + new Date().toLocaleString('pt-BR') + '\n';
  engContent += '; Sess√£o: ' + session.nome + '\n';
  
  // Se houver massa de propelente, adiciona informa√ß√£o
  if (metadados.massaPropelente) {
    engContent += '; Massa de propelente informada: ' + metadados.massaPropelente.toFixed(2) + ' g\n';
  }
  
  engContent += '; N√∫mero de leituras: ' + session.dadosTabela.length + '\n';
  engContent += ';\n';
  
  // Dados de impulso (tempo em segundos, for√ßa em Newtons)
  // Formato: tempo(s)  for√ßa(N)
  session.dadosTabela.forEach(leitura => {
    const tempo = parseFloat(leitura.tempo_esp) || 0;
    const newtons = parseFloat(leitura.newtons) || 0;
    engContent += tempo.toFixed(5) + '\t' + newtons.toFixed(5) + '\n';
  });
  
  // Download do arquivo
  const blob = new Blob([engContent], { type: 'text/plain;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = nomeArquivo;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showNotification('success', 'Arquivo .ENG compat√≠vel com OpenRocket gerado!');
}



async function gerarRelatorioPdf(sessionId, source) {
  const session = await getSessionDataForExport(sessionId, source);
  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para relat√≥rio PDF.');
    return;
  }

  showNotification('info', 'Gerando relat√≥rio PDF com gr√°fico...', 2000);

  // Processa dados
  const dados = processarDadosSimples(session.dadosTabela);
  const impulsoData = calcularAreaSobCurva(dados.tempos, dados.newtons, false);
  
  // Obt√©m massa do propelente em kg (converte de gramas se necess√°rio)
  let massaPropelente = null;
  if (session.metadadosMotor && session.metadadosMotor.massaPropelente) {
    massaPropelente = session.metadadosMotor.massaPropelente / 1000; // Converte de gramas para kg
  }
  
  const metricasPropulsao = calcularMetricasPropulsao(impulsoData, massaPropelente);

  // Gera o gr√°fico em canvas e converte para imagem
  gerarGraficoParaPDF(session, dados, impulsoData, metricasPropulsao, (imagemBase64) => {
    // Cria janela de impress√£o com o gr√°fico
    const printWindow = window.open('', '_blank');

    // Gera HTML do relat√≥rio COM a imagem do gr√°fico
    const html = gerarHTMLRelatorioCompleto(session, dados, impulsoData, metricasPropulsao, imagemBase64);

    printWindow.document.write(html);
    printWindow.document.close();

    // Aguarda carregamento e abre di√°logo de impress√£o
    printWindow.onload = function () {
      setTimeout(() => {
        printWindow.print();
      }, 500);
    };

    showNotification('success', 'Relat√≥rio pronto! Use "Salvar como PDF" no di√°logo', 5000);
  });
}

async function exportarCSV(sessionId, source) {
  const session = await getSessionDataForExport(sessionId, source);
  if (!session) {
    showNotification('error', 'Sess√£o n√£o encontrada para exporta√ß√£o CSV.');
    return;
  }

  let csvContent = "Timestamp,Tempo ESP (s),Newtons (N),Grama-for√ßa (gf),Quilo-for√ßa (kgf)\n";
  session.dadosTabela.forEach(leitura => {
    csvContent += leitura.timestamp + ',' + leitura.tempo_esp + ',' + leitura.newtons + ',' + leitura.grama_forca + ',' + leitura.quilo_forca + '\n';
  });

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = session.nome.replace(/[^a-zA-Z0-9_]/g, '_') + '.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  showNotification('success', 'Arquivo CSV para "' + session.nome + '" gerado!');
}

function deleteLocalSession(sessionId) {
  if (!confirm('Tem certeza que deseja excluir a sess√£o ' + sessionId + ' do Local Storage?')) {
    return;
  }
  let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  gravacoes = gravacoes.filter(s => s.id !== sessionId);
  localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
  showNotification('success', 'Sess√£o ' + sessionId + ' exclu√≠da do Local Storage.');
  loadAndDisplayAllSessions(); // Re-render the list
}

async function deleteDbSession(sessionId) {
  if (!confirm('Tem certeza que deseja excluir a sess√£o ' + sessionId + ' do banco de dados? Esta a√ß√£o n√£o pode ser desfeita.')) {
    return;
  }
  try {
    const response = await apiFetch(`/api/sessoes/${sessionId}`, { method: 'DELETE' });
    if (!response.ok) throw new Error('Falha ao excluir a sess√£o do DB.');

    showNotification('success', 'Sess√£o ' + sessionId + ' exclu√≠da do banco de dados.');
    loadAndDisplayAllSessions(); // Re-render the list
  } catch (error) {
    console.error('Erro ao excluir sess√£o do DB:', error);
    showNotification('error', 'Erro ao excluir a sess√£o ' + sessionId + ' do DB.');
  }
}

async function saveDbSessionToLocal(sessionId) {
  try {
    // Fetch session details from DB
    const dbSessionResponse = await apiFetch('/api/sessoes');
    if (!dbSessionResponse.ok) throw new Error('Falha ao carregar detalhes da sess√£o do DB para salvar localmente.');
    const allDbSessions = await dbSessionResponse.json();
    const dbSession = allDbSessions.find(s => s.id === sessionId);

    if (!dbSession) {
      showNotification('error', 'Sess√£o do DB n√£o encontrada para salvar localmente.');
      return;
    }

    // Fetch readings from DB
    const readingsResponse = await apiFetch('/api/sessoes/' + sessionId + '/leituras');
    if (!readingsResponse.ok) throw new Error('Falha ao carregar leituras do DB para salvar localmente.');
    const dbReadings = await readingsResponse.json();

    const gravacao = {
      id: dbSession.id,
      nome: dbSession.nome,
      timestamp: dbSession.data_inicio,
      data_modificacao: dbSession.data_modificacao || new Date().toISOString(),
      dadosTabela: dbReadings.map(r => ({
        timestamp: formatUtcDdMm(parseDbTimestampToUTC(r.timestamp)),
        tempo_esp: r.tempo,
        newtons: r.forca,
        grama_forca: (r.forca / 9.80665 * 1000),
        quilo_forca: (r.forca / 9.80665)
      })),
      metadadosMotor: dbSession.metadadosMotor || {},
      savedToMysql: true // Mark as saved to MySQL since it came from there
    };

    let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
    // Check if already exists in local storage to avoid duplicates
    const existingIndex = gravacoes.findIndex(s => s.id === sessionId);
    if (existingIndex === -1) {
      gravacoes.push(gravacao);
      showNotification('success', 'Sess√£o "' + dbSession.nome + '" salva localmente!');
    } else {
      // Atualiza a sess√£o existente
      gravacoes[existingIndex] = gravacao;
      showNotification('success', 'Sess√£o "' + dbSession.nome + '" atualizada localmente!');
    }
    localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
    loadAndDisplayAllSessions(); // Re-render to update status

  } catch (error) {
    console.error('Erro ao salvar sess√£o do DB localmente:', error);
    showNotification('error', 'Erro ao salvar sess√£o ' + sessionId + ' localmente.');
  }
}

async function saveLocalSessionToDb(sessionId) {
  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  const sessionToSave = localSessions.find(s => s.id === sessionId);

  if (!sessionToSave) {
    showNotification('error', 'Sess√£o local n√£o encontrada para salvar no DB.');
    return;
  }

  if (isMysqlConnected) {
    showNotification('info', 'Enviando sess√£o "' + sessionToSave.nome + '" para o MySQL...');
    sendCommandToWorker('save_session_to_mysql', sessionToSave);
    // The worker will send back mysql_save_success/error, which will trigger loadAndDisplayAllSessions
  } else {
    showNotification('error', 'N√£o foi poss√≠vel salvar no MySQL: Banco de dados desconectado.');
  }
}

async function resolverConflito(sessionId) {
  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  const localSession = localSessions.find(s => s.id === sessionId);

  let dbSession = null;
  try {
    const resp = await apiFetch(`/api/sessoes/${sessionId}`);
    if (resp.ok) {
      dbSession = await resp.json();
    }
  } catch (e) {
    console.error('Erro ao buscar sess√£o do DB:', e);
    showNotification('error', 'Erro ao buscar dados do banco para compara√ß√£o.');
    return;
  }

  if (!localSession || !dbSession) {
    showNotification('error', 'N√£o foi poss√≠vel carregar ambas as vers√µes para compara√ß√£o.');
    return;
  }

  const localDate = localSession.data_modificacao ? new Date(localSession.data_modificacao).toLocaleString('pt-BR') : 'Desconhecida';
  const dbDate = dbSession.data_modificacao ? new Date(dbSession.data_modificacao).toLocaleString('pt-BR') : 'Desconhecida';

  // Metadados do motor para compara√ß√£o
  const localMeta = localSession.metadadosMotor || {};
  const dbMeta = dbSession.metadadosMotor || {};

  const formatMetaValue = (val) => val !== undefined && val !== null && val !== '' ? val : 'N/D';

  const metadadosLocalHtml = `
    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 0.85rem;">
      <strong style="color: #3498db;">üöÄ Metadados do Motor:</strong>
      <div style="margin-top: 5px; line-height: 1.6;">
        <div><strong>Nome:</strong> ${formatMetaValue(localMeta.name)}</div>
        <div><strong>Di√¢metro:</strong> ${formatMetaValue(localMeta.diameter)} mm</div>
        <div><strong>Comprimento:</strong> ${formatMetaValue(localMeta.length)} mm</div>
        <div><strong>Delay:</strong> ${formatMetaValue(localMeta.delay)} s</div>
        <div><strong>Peso Propelente:</strong> ${formatMetaValue(localMeta.propweight)} kg</div>
        <div><strong>Peso Total:</strong> ${formatMetaValue(localMeta.totalweight)} kg</div>
        <div><strong>Fabricante:</strong> ${formatMetaValue(localMeta.manufacturer)}</div>
        ${localMeta.description ? `<div style="margin-top: 5px;"><strong>Descri√ß√£o:</strong> ${localMeta.description}</div>` : ''}
        ${localMeta.observations ? `<div style="margin-top: 5px;"><strong>Observa√ß√µes:</strong> ${localMeta.observations}</div>` : ''}
      </div>
    </div>
  `;

  const metadadosDbHtml = `
    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 0.85rem;">
      <strong style="color: #9b59b6;">üöÄ Metadados do Motor:</strong>
      <div style="margin-top: 5px; line-height: 1.6;">
        <div><strong>Nome:</strong> ${formatMetaValue(dbMeta.name)}</div>
        <div><strong>Di√¢metro:</strong> ${formatMetaValue(dbMeta.diameter)} mm</div>
        <div><strong>Comprimento:</strong> ${formatMetaValue(dbMeta.length)} mm</div>
        <div><strong>Delay:</strong> ${formatMetaValue(dbMeta.delay)} s</div>
        <div><strong>Peso Propelente:</strong> ${formatMetaValue(dbMeta.propweight)} kg</div>
        <div><strong>Peso Total:</strong> ${formatMetaValue(dbMeta.totalweight)} kg</div>
        <div><strong>Fabricante:</strong> ${formatMetaValue(dbMeta.manufacturer)}</div>
        ${dbMeta.description ? `<div style="margin-top: 5px;"><strong>Descri√ß√£o:</strong> ${dbMeta.description}</div>` : ''}
        ${dbMeta.observations ? `<div style="margin-top: 5px;"><strong>Observa√ß√µes:</strong> ${dbMeta.observations}</div>` : ''}
      </div>
    </div>
  `;

  const modalHtml = `
    <div id="modal-conflito" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;">
      <div style="background: var(--cor-fundo); padding: 30px; border-radius: 12px; max-width: 900px; width: 95%; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
        <h2 style="margin-top: 0; color: #e74c3c;">‚ö†Ô∏è Conflito de Sincroniza√ß√£o Detectado</h2>
        <p style="color: var(--cor-texto); margin-bottom: 20px;">
          A sess√£o "<strong>${localSession.nome}</strong>" possui vers√µes diferentes no LocalStorage e no Banco de Dados.
          Escolha qual vers√£o deseja manter:
        </p>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
          <div style="border: 2px solid #3498db; border-radius: 8px; padding: 15px; background: rgba(52, 152, 219, 0.1);">
            <h3 style="margin-top: 0; color: #3498db; font-size: 1.1rem;">üíæ Vers√£o Local</h3>
            <p style="margin: 5px 0;"><strong>Modificada em:</strong> ${localDate}</p>
            <p style="margin: 5px 0; font-size: 0.9rem; color: var(--cor-texto-secundario);">
              Dados salvos no navegador deste dispositivo.
            </p>
            ${metadadosLocalHtml}
            <button onclick="resolverConflito_UsarLocal(${sessionId})" class="btn btn-primario" style="width: 100%; margin-top: 10px;">
              ‚úì Usar Vers√£o Local
            </button>
          </div>

          <div style="border: 2px solid #9b59b6; border-radius: 8px; padding: 15px; background: rgba(155, 89, 182, 0.1);">
            <h3 style="margin-top: 0; color: #9b59b6; font-size: 1.1rem;">‚òÅÔ∏è Vers√£o do Banco</h3>
            <p style="margin: 5px 0;"><strong>Modificada em:</strong> ${dbDate}</p>
            <p style="margin: 5px 0; font-size: 0.9rem; color: var(--cor-texto-secundario);">
              Dados salvos no banco de dados (sincronizados).
            </p>
            ${metadadosDbHtml}
            <button onclick="resolverConflito_UsarDB(${sessionId})" class="btn btn-secundario" style="width: 100%; margin-top: 10px;">
              ‚úì Usar Vers√£o do Banco
            </button>
          </div>
        </div>

        <div style="display: flex; gap: 10px; justify-content: center;">
          <button onclick="fecharModalConflito()" class="btn btn-perigo">‚úó Cancelar</button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function fecharModalConflito() {
  const modal = document.getElementById('modal-conflito');
  if (modal) modal.remove();
}

async function resolverConflito_UsarLocal(sessionId) {
  const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
  const localSession = localSessions.find(s => s.id === sessionId);

  if (!localSession) {
    showNotification('error', 'Sess√£o local n√£o encontrada.');
    fecharModalConflito();
    return;
  }

  // Atualiza data de modifica√ß√£o e envia para o banco
  localSession.data_modificacao = new Date().toISOString();

  // Atualiza no localStorage
  const sessionIndex = localSessions.findIndex(s => s.id === sessionId);
  localSessions[sessionIndex] = localSession;
  localStorage.setItem('balancaGravacoes', JSON.stringify(localSessions));

  if (isMysqlConnected) {
    sendCommandToWorker('save_session_to_mysql', localSession);
    showNotification('success', 'Vers√£o local enviada para o banco de dados.');
  } else {
    showNotification('warning', 'MySQL desconectado. Vers√£o local mantida, mas n√£o sincronizada.');
  }

  fecharModalConflito();
  setTimeout(() => loadAndDisplayAllSessions(), 500);
}

async function resolverConflito_UsarDB(sessionId) {
  try {
    const resp = await apiFetch(`/api/sessoes/${sessionId}`);
    if (!resp.ok) {
      throw new Error('Erro ao buscar sess√£o do banco');
    }

    const dbSession = await resp.json();

    // Busca as leituras
    const readingsResp = await apiFetch(`/api/sessoes/${sessionId}/leituras`);
    if (readingsResp.ok) {
      const dbReadings = await readingsResp.json();
      dbSession.dadosTabela = dbReadings.map(r => ({
        timestamp: formatUtcDdMm(parseDbTimestampToUTC(r.timestamp)),
        tempo_esp: r.tempo,
        newtons: r.forca,
        grama_forca: (r.forca / 9.80665 * 1000),
        quilo_forca: (r.forca / 9.80665)
      }));
    }

    // Normaliza os campos
    if (dbSession.data_inicio && !dbSession.timestamp) {
      dbSession.timestamp = dbSession.data_inicio;
    }
    if (!dbSession.data_modificacao) {
      dbSession.data_modificacao = new Date().toISOString();
    }

    // Atualiza no localStorage
    const localSessions = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
    const sessionIndex = localSessions.findIndex(s => s.id === sessionId);

    if (sessionIndex !== -1) {
      localSessions[sessionIndex] = dbSession;
    } else {
      localSessions.push(dbSession);
    }

    localStorage.setItem('balancaGravacoes', JSON.stringify(localSessions));
    showNotification('success', 'Vers√£o do banco baixada para o LocalStorage.');

    fecharModalConflito();
    setTimeout(() => loadAndDisplayAllSessions(), 500);

  } catch (error) {
    console.error('Erro ao buscar sess√£o do DB:', error);
    showNotification('error', 'Erro ao baixar vers√£o do banco de dados.');
    fecharModalConflito();
  }
}

async function importarGravacaoExterna() {
  const fileInput = document.getElementById('importar-arquivo-motor');
  const nomeImportacaoInput = document.getElementById('nome-importacao');
  const file = fileInput.files[0];
  const nome = nomeImportacaoInput.value.trim();

  if (!file || !nome) {
    showNotification('error', 'Por favor, selecione um arquivo e insira um nome para a importa√ß√£o.');
    return;
  }

  const reader = new FileReader();
  reader.onload = async (e) => {
    const content = e.target.result;
    const linhas = content.split('\n').filter(line => line.trim() !== '');
    const dadosTabela = linhas.map((linha, index) => {
      const partes = linha.trim().split(/\s+/);
      if (partes.length >= 2) {
        return {
          timestamp: new Date(Date.now() + index).toLocaleString('pt-BR', { hour12: false }).replace(', ', ' '), // Unique timestamp
          tempo_esp: parseFloat(partes[0]),
          newtons: parseFloat(partes[1]),
          grama_forca: parseFloat(partes[1]) / 9.80665 * 1000,
          quilo_forca: parseFloat(partes[1]) / 9.80665
        };
      }
      return null;
    }).filter(Boolean);

    if (dadosTabela.length === 0) {
      showNotification('error', 'Nenhum dado v√°lido encontrado no arquivo importado.');
      return;
    }

    const gravacao = {
      id: Date.now(),
      nome: nome,
      timestamp: new Date().toISOString(),
      data_modificacao: new Date().toISOString(),
      dadosTabela: dadosTabela,
      metadadosMotor: {},
      source: 'local', // Initially local
      inLocal: true,
      inDb: false
    };

    try {
      let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
      gravacoes.push(gravacao);
      localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
      showNotification('success', 'Sess√£o "' + nome + '" importada e salva localmente!');

      // Also save to DB if connected
      if (isMysqlConnected) {
        showNotification('info', 'Enviando sess√£o importada "' + nome + '" para o MySQL...');
        sendCommandToWorker('save_session_to_mysql', gravacao);
      }

      loadAndDisplayAllSessions(); // Re-render the list
      fileInput.value = '';
      nomeImportacaoInput.value = '';
    } catch (e) {
      showNotification('error', 'Erro ao salvar importa√ß√£o. O Local Storage pode estar cheio.');
    }
  };
  reader.readAsText(file);
}

// --- Fun√ß√£o para Importar Grava√ß√£o JSON Exportada ---
async function importarGravacaoJSON() {
  const fileInput = document.getElementById('importar-json');
  const file = fileInput.files[0];

  if (!file) {
    showNotification('error', 'Por favor, selecione um arquivo JSON para importar.');
    return;
  }

  const reader = new FileReader();
  reader.onload = async (e) => {
    try {
      const content = e.target.result;
      const gravacaoImportada = JSON.parse(content);

      // Validar estrutura b√°sica do JSON
      if (!gravacaoImportada.nome || !gravacaoImportada.dadosTabela || !Array.isArray(gravacaoImportada.dadosTabela)) {
        showNotification('error', 'Arquivo JSON inv√°lido. Certifique-se de que √© uma exporta√ß√£o v√°lida.');
        return;
      }

      // Gerar novo ID e atualizar timestamps
      const novaGravacao = {
        ...gravacaoImportada,
        id: Date.now(), // Novo ID √∫nico
        data_modificacao: new Date().toISOString(),
        source: 'local', // Marcar como local
        inLocal: true,
        inDb: false
      };

      // Se n√£o tiver timestamp, adicionar
      if (!novaGravacao.timestamp) {
        novaGravacao.timestamp = new Date().toISOString();
      }

      // Salvar no localStorage
      let gravacoes = JSON.parse(localStorage.getItem('balancaGravacoes')) || [];
      
      // Verificar se j√° existe uma grava√ß√£o com o mesmo nome
      const nomeExistente = gravacoes.some(g => g.nome === novaGravacao.nome);
      if (nomeExistente) {
        const confirmar = confirm(`J√° existe uma grava√ß√£o com o nome "${novaGravacao.nome}". Deseja importar mesmo assim com um nome diferente?`);
        if (confirmar) {
          novaGravacao.nome = `${novaGravacao.nome} (importada ${new Date().toLocaleTimeString('pt-BR')})`;
        } else {
          fileInput.value = '';
          return;
        }
      }

      gravacoes.push(novaGravacao);
      localStorage.setItem('balancaGravacoes', JSON.stringify(gravacoes));
      
      showNotification('success', `Grava√ß√£o "${novaGravacao.nome}" importada com sucesso! (${novaGravacao.dadosTabela.length} pontos)`);

      // Tamb√©m salvar no MySQL se conectado
      if (isMysqlConnected) {
        showNotification('info', `Enviando grava√ß√£o "${novaGravacao.nome}" para o MySQL...`);
        sendCommandToWorker('save_session_to_mysql', novaGravacao);
      }

      // Recarregar lista de grava√ß√µes
      loadAndDisplayAllSessions();
      fileInput.value = '';

    } catch (error) {
      console.error('Erro ao importar JSON:', error);
      showNotification('error', `Erro ao importar arquivo JSON: ${error.message}`);
      fileInput.value = '';
    }
  };
  
  reader.readAsText(file);
}

// --- Fun√ß√µes do Rel√≥gio do Servidor ---

async function updateServerClock() {
  try {
    const response = await apiFetch('/api/time');
    if (response.ok) {
      const data = await response.json();
      const serverTime = new Date(data.time);
      const clientTime = new Date();

      // Calcula o offset entre servidor e cliente
      serverTimeOffset = serverTime.getTime() - clientTime.getTime();

      // Atualiza o display
      updateClockDisplay();
    }
  } catch (error) {
    console.error('Erro ao buscar hora do servidor:', error);
    document.getElementById('server-clock').textContent = 'Erro';
  }
}

function updateClockDisplay() {
  // Cria um Date object com a hora do servidor ajustada
  const now = new Date(Date.now() + serverTimeOffset);
  
  // getHours(), getMinutes(), getSeconds() j√° retornam no timezone LOCAL do navegador
  // Isso est√° correto! Se o servidor est√° em UTC e retorna 10:00, e o navegador
  // est√° em GMT-3, o Date object automaticamente mostra 07:00 localmente
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');

  const clockElement = document.getElementById('server-clock');
  if (clockElement) {
    clockElement.textContent = `${hours}:${minutes}:${seconds}`;
  }
}

async function syncServerTime() {
  // Pega a hora LOCAL do navegador (a hora real que o usu√°rio est√° vendo)
  const clientTime = new Date();
  
  // Formata a hora local para exibi√ß√£o (HH:MM:SS)
  const hours = String(clientTime.getHours()).padStart(2, '0');
  const minutes = String(clientTime.getMinutes()).padStart(2, '0');
  const seconds = String(clientTime.getSeconds()).padStart(2, '0');
  const displayedTime = `${hours}:${minutes}:${seconds}`;

  if (!confirm(`Sincronizar hora do servidor com a hora atual do navegador?\n\nHora do Navegador: ${displayedTime}\n\nATEN√á√ÉO: Isso ir√° ajustar a hora do sistema do servidor!`)) {
    return;
  }

  try {
    // Envia a hora LOCAL do navegador para o servidor
    // O servidor receber√° em GMT/UTC e ajustar√° conforme seu timezone
    const response = await apiFetch('/api/time/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ time: clientTime.toISOString() })
    });

    if (response.ok) {
      const data = await response.json();

      // Verifica se h√° warning (sincroniza√ß√£o simulada)
      if (data.warning) {
        showNotification('warning', data.message);
      } else {
        showNotification('success', data.message || 'Hora do servidor sincronizada com sucesso!');
      }

      // Atualiza imediatamente
      await updateServerClock();
    } else {
      // Tenta ler como JSON primeiro, depois como texto
      try {
        const errorData = await response.json();

        // Se for erro de permiss√£o, mostra modal com instru√ß√µes
        if (response.status === 403 && errorData.message) {
          showPermissionErrorModal(errorData.message, errorData.requested_time);
        } else {
          const errorMsg = errorData.error || errorData.message || JSON.stringify(errorData);
          console.error('Erro completo:', errorMsg);
          showNotification('error', `Erro ao sincronizar: ${errorMsg}`);
        }
      } catch {
        const errorText = await response.text();
        // Extrai a mensagem de erro do HTML se poss√≠vel
        const match = errorText.match(/<title>.*?(\d+)\s+([^<]+)<\/title>/);
        if (match) {
          showNotification('error', `Erro ao sincronizar: ${match[1]} - ${match[2]}`);
        } else {
          showNotification('error', `Erro ao sincronizar: Erro ${response.status}`);
        }
        console.error('Erro completo:', errorText);
      }
    }
  } catch (error) {
    console.error('Erro ao sincronizar hora:', error);
    showNotification('error', 'Erro de conex√£o ao sincronizar hora do servidor.');
  }
}

function showPermissionErrorModal(message, requestedTime) {
  const requestedDate = requestedTime ? new Date(requestedTime).toLocaleString('pt-BR') : 'N/D';

  const modalHtml = `
    <div id="modal-permission-error" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;">
      <div style="background: var(--cor-fundo); padding: 30px; border-radius: 12px; max-width: 650px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
        <h2 style="margin-top: 0; color: #e67e22;">üîí Permiss√£o Necess√°ria</h2>
        <p style="color: var(--cor-texto); margin-bottom: 15px;">
          <strong>Hora solicitada:</strong> ${requestedDate}
        </p>

        <div style="background: #34495e; color: #ecf0f1; padding: 15px; border-radius: 8px; margin-bottom: 20px; white-space: pre-wrap; font-family: monospace; font-size: 0.85rem; line-height: 1.6;">
${message}
        </div>

        <div style="display: flex; gap: 10px; justify-content: center;">
          <button onclick="closePermissionErrorModal()" class="btn btn-primario">Entendido</button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closePermissionErrorModal() {
  const modal = document.getElementById('modal-permission-error');
  if (modal) modal.remove();
}

// Fun√ß√£o para buscar IPs p√∫blicos do servidor
async function buscarIPsPublicos() {
  const ipv4Element = document.getElementById('ip-publico-v4');
  const ipv6Element = document.getElementById('ip-publico-v6');
  
  if (!ipv4Element || !ipv6Element) {
    console.error('Elementos de IP n√£o encontrados');
    return;
  }

  try {
    const response = await fetch('/api/public-ips');
    
    if (!response.ok) {
      throw new Error(`Erro HTTP: ${response.status}`);
    }
    
    const data = await response.json();
    
    // Atualiza IPv4
    if (data.ipv4 && data.ipv4 !== 'Erro ao obter' && data.ipv4 !== 'N√£o dispon√≠vel') {
      ipv4Element.innerHTML = `
        <code style="font-family: 'Courier New', monospace; background: var(--cor-fundo-card); padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--cor-borda); font-weight: 600; color: var(--cor-primaria); font-size: 0.9rem;">${data.ipv4}</code>
        <button onclick="copiarIP('${data.ipv4}')" class="btn-copy" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; cursor: pointer; background: var(--cor-primaria); color: white; border: none; border-radius: 0.25rem; transition: opacity 0.2s;" title="Copiar IPv4">üìã</button>
      `;
    } else {
      ipv4Element.innerHTML = `<span style="color: var(--cor-texto-secundario); font-size: 0.875rem;">${data.ipv4 || 'N√£o dispon√≠vel'}</span>`;
    }
    
    // Atualiza IPv6
    if (data.ipv6 && data.ipv6 !== 'Erro ao obter' && data.ipv6 !== 'N√£o dispon√≠vel') {
      ipv6Element.innerHTML = `
        <code style="font-family: 'Courier New', monospace; background: var(--cor-fundo-card); padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--cor-borda); font-weight: 600; color: var(--cor-primaria); font-size: 0.9rem;">${data.ipv6}</code>
        <button onclick="copiarIP('${data.ipv6}')" class="btn-copy" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; cursor: pointer; background: var(--cor-primaria); color: white; border: none; border-radius: 0.25rem; transition: opacity 0.2s;" title="Copiar IPv6">üìã</button>
      `;
    } else {
      ipv6Element.innerHTML = `<span style="color: var(--cor-texto-secundario); font-size: 0.875rem;">${data.ipv6 || 'N√£o dispon√≠vel'}</span>`;
    }
  } catch (error) {
    console.error('Erro ao buscar IPs p√∫blicos:', error);
    ipv4Element.innerHTML = '<span style="color: #ef4444; font-size: 0.875rem;">Erro na conex√£o</span>';
    ipv6Element.innerHTML = '<span style="color: #ef4444; font-size: 0.875rem;">Erro na conex√£o</span>';
  }
}

// Fun√ß√£o para copiar IP para √°rea de transfer√™ncia no formato URL
function copiarIP(ip) {
  // Formatar como URL completa
  let url;
  if (ip.includes(':')) {
    // IPv6 - precisa de colchetes
    url = `http://[${ip}]`;
  } else {
    // IPv4 - formato simples
    url = `http://${ip}`;
  }
  
  navigator.clipboard.writeText(url).then(() => {
    showNotification(`URL copiada: ${url}`, 'success');
  }).catch(err => {
    console.error('Erro ao copiar URL:', err);
    showNotification('Erro ao copiar URL', 'error');
  });
}

// ============================================
// === PERSIST√äNCIA DE CONFIGURA√á√ïES DO GR√ÅFICO ===
// ============================================

/**
 * Salva as configura√ß√µes do gr√°fico no localStorage
 */
function salvarConfiguracoesGrafico() {
  const config = {
    chartMode: chartMode,
    displayUnit: displayUnit,
    antiNoisingAtivo: antiNoisingAtivo,
    antiNoisingMultiplier: antiNoisingMultiplier,
    filtroZonaMortaAtivo: filtroZonaMortaAtivo,
    arredondamentoInteligenteAtivo: arredondamentoInteligenteAtivo,
    MAX_DATA_POINTS: MAX_DATA_POINTS,
    avisosAudioAtivados: avisosAudioAtivados,
    taxaAtualizacaoMs: taxaAtualizacaoMs
  };
  
  try {
    localStorage.setItem('balanca_config_grafico', JSON.stringify(config));
    console.log('[Config] Configura√ß√µes do gr√°fico salvas:', config);
  } catch (e) {
    console.error('[Config] Erro ao salvar configura√ß√µes:', e);
  }
}

/**
 * Carrega as configura√ß√µes do gr√°fico do localStorage
 */
function carregarConfiguracoesGrafico() {
  try {
    const configSalva = localStorage.getItem('balanca_config_grafico');
    if (!configSalva) {
      console.log('[Config] Nenhuma configura√ß√£o salva encontrada');
      return;
    }
    
    const config = JSON.parse(configSalva);
    console.log('[Config] Carregando configura√ß√µes salvas:', config);
    
    // Aplicar configura√ß√µes
    if (config.chartMode !== undefined) chartMode = config.chartMode;
    if (config.displayUnit !== undefined) displayUnit = config.displayUnit;
    if (config.antiNoisingAtivo !== undefined) antiNoisingAtivo = config.antiNoisingAtivo;
    if (config.antiNoisingMultiplier !== undefined) antiNoisingMultiplier = config.antiNoisingMultiplier;
    if (config.filtroZonaMortaAtivo !== undefined) filtroZonaMortaAtivo = config.filtroZonaMortaAtivo;
    if (config.arredondamentoInteligenteAtivo !== undefined) arredondamentoInteligenteAtivo = config.arredondamentoInteligenteAtivo;
    if (config.MAX_DATA_POINTS !== undefined) MAX_DATA_POINTS = config.MAX_DATA_POINTS;
    if (config.avisosAudioAtivados !== undefined) avisosAudioAtivados = config.avisosAudioAtivados;
    if (config.taxaAtualizacaoMs !== undefined) taxaAtualizacaoMs = config.taxaAtualizacaoMs;
    
    // Atualizar interface para refletir as configura√ß√µes carregadas
    atualizarInterfaceConfiguracao();
    
    console.log('[Config] Configura√ß√µes aplicadas com sucesso');
  } catch (e) {
    console.error('[Config] Erro ao carregar configura√ß√µes:', e);
  }
}

/**
 * Atualiza a interface para refletir as configura√ß√µes carregadas
 */
function atualizarInterfaceConfiguracao() {
  // Atualizar modo do gr√°fico (deslizante, acumulado, pausado)
  document.querySelectorAll('#btn-deslizante, #btn-acumulado, #btn-pausado').forEach(b => b.classList.remove('ativo'));
  const btnModoAtual = document.getElementById(`btn-${chartMode}`);
  if (btnModoAtual) btnModoAtual.classList.add('ativo');
  
  // Atualizar unidade de exibi√ß√£o (N, gf, kgf)
  document.querySelectorAll('#btn-unit-n, #btn-unit-gf, #btn-unit-kgf').forEach(b => b.classList.remove('ativo'));
  const btnUnidadeAtual = document.getElementById(`btn-unit-${displayUnit.toLowerCase()}`);
  if (btnUnidadeAtual) btnUnidadeAtual.classList.add('ativo');
  
  // Atualizar bot√µes de filtros
  const btnZonaMorta = document.getElementById('btn-zona-morta');
  if (btnZonaMorta) {
    btnZonaMorta.textContent = 'Zona Morta: ' + (filtroZonaMortaAtivo ? 'ON' : 'OFF');
    btnZonaMorta.style.background = filtroZonaMortaAtivo ? '#27ae60' : '#95a5a6';
  }
  
  const btnArredondamento = document.getElementById('btn-arredondamento');
  if (btnArredondamento) {
    btnArredondamento.textContent = 'Arredondar: ' + (arredondamentoInteligenteAtivo ? 'ON' : 'OFF');
    btnArredondamento.style.background = arredondamentoInteligenteAtivo ? '#27ae60' : '#95a5a6';
  }
  
  // Atualizar checkbox de avisos de √°udio
  const audioCheckbox = document.getElementById('audio-avisos');
  if (audioCheckbox) audioCheckbox.checked = avisosAudioAtivados;
  
  // Atualizar status dos filtros
  atualizarStatusFiltros();
  
  // Atualizar taxa de atualiza√ß√£o no input
  const taxaInput = document.getElementById('taxa-atualizacao');
  if (taxaInput) taxaInput.value = taxaAtualizacaoMs;
  
  // Atualizar MAX_DATA_POINTS no input
  const maxPointsInput = document.getElementById('max-data-points-input');
  if (maxPointsInput) maxPointsInput.value = MAX_DATA_POINTS;
  
  // Atualizar anti-noising multiplier (se existir campo)
  const antiNoisingInput = document.getElementById('antinoising-multiplier');
  if (antiNoisingInput) antiNoisingInput.value = antiNoisingMultiplier;
  
  console.log('[Config] Interface atualizada com configura√ß√µes salvas');
}

// Interceptar mudan√ßas para salvar automaticamente
const _toggleAntiNoising = toggleAntiNoising;
toggleAntiNoising = function() {
  _toggleAntiNoising();
  salvarConfiguracoesGrafico();
};

const _setAntiNoisingMultiplier = setAntiNoisingMultiplier;
setAntiNoisingMultiplier = function(multiplier) {
  _setAntiNoisingMultiplier(multiplier);
  salvarConfiguracoesGrafico();
};

// Inicializa o rel√≥gio
window.addEventListener('load', () => {
  // Busca a hora inicial
  updateServerClock();

  // Atualiza o display a cada segundo (independente de buscar do servidor)
  setInterval(updateClockDisplay, 1000);
  
  // Busca IPs p√∫blicos
  buscarIPsPublicos();
  
  // Listener para fechar modal ao clicar fora dele
  const modalSobrecarga = document.getElementById('modal-alerta-sobrecarga');
  if (modalSobrecarga) {
    modalSobrecarga.addEventListener('click', (e) => {
      if (e.target === modalSobrecarga) {
        fecharModalSobrecarga();
      }
    });
  }

  // Busca a hora do servidor a cada 5 minutos para corrigir drift
  setInterval(updateServerClock, 5 * 60 * 1000);
});